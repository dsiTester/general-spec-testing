[
    {
        "iid": 1,
        "inspection-start-time": "2022-02-02-20-05",
        "project": "commons-exec",
        "spec-id": "00004",
        "method-a": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;)Lorg/apache/commons/exec/CommandLine;",
        "method-b": "org.apache.commons.exec.CommandLine.setSubstitutionMap(Ljava/util/Map;)V",
        "method-a-return-type": "org.apache.commons.exec.CommandLine",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00004.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testCopyConstructor",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLineTest.java:513",
                        "method-b-site": "CommandLineTest.java:514",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "The test does not fail if method-a is commented out"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testCopyConstructor",
        "notes": "method-a sets the field variable CommandLine.arguments, and method-b is a pure setter to the field variable CommandLine.substitutionMap (ONE_PURE_SETTER). These two field variables are unrelated.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-02-20-08",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 2,
        "inspection-start-time": "2022-02-02-20-37",
        "project": "commons-exec",
        "spec-id": "00008",
        "method-a": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-b": "org.apache.commons.exec.CommandLine.setSubstitutionMap(Ljava/util/Map;)V",
        "method-a-return-type": "org.apache.commons.exec.CommandLine",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00008.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testCopyConstructor",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "CommandLineTest.java:514",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "The test does not fail if method-a is commented out"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testCopyConstructor",
        "notes": "method-a sets the field variable CommandLine.arguments, and method-b is a pure setter to the field variable CommandLine.substitutionMap (ONE_PURE_SETTER). These two field variables are unrelated.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-02-20-39",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 3,
        "inspection-start-time": "2022-02-02-00-49",
        "project": "commons-exec",
        "spec-id": "00026",
        "method-a": "org.apache.commons.exec.CommandLine.getSubstitutionMap()Ljava/util/Map;",
        "method-b": "org.apache.commons.exec.CommandLine.getArguments()[Ljava/lang/String;",
        "method-a-return-type": "java.util.Map",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 29,
        "code-snippets-file": "snippets/ls/00026.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplication",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:324",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_CORRECT_VALUE_NONASSERTION - method-a on a normal execution returns null, and DSI replaced the return value of method-a with null.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplication",
        "notes": "ONE_STATELESS_METHOD - method-a is a 1-line naive getter that returns the value of the field variable CommandLine.substitutionMap, and method-b can access but does not modify the field value (method-b can call method-a, so this is a kind of a REVERSE_NBP). Hence, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-00-54",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 4,
        "inspection-start-time": "2022-02-03-01-10",
        "project": "commons-exec",
        "spec-id": "00030",
        "method-a": "org.apache.commons.exec.CommandLine.setSubstitutionMap(Ljava/util/Map;)V",
        "method-b": "org.apache.commons.exec.CommandLine.getExecutable()Ljava/lang/String;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.String",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00030.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testParseComplexCommandLine1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:88",
                        "method-b-site": "CommandLine.java:298",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test doesn't fail because the executable name did not need any substitution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "NA",
        "notes": "method-a is a pure setter for the field variable CommandLine.substitutionMap (ONE_PURE_SETTER), and method-b accesses CommandLine.substitutionMap in order to figure out where string substitution for variables in the command line (executable) need to be done. Hence, this is a true spec. While there is a CommandLine constructor (CommandLine(CommandLine)) that sets the field variable CommandLine.substitutionMap, that constructor is used as a means to create a CommandLine object that is a copy of its argument. Plus, it only initializes CommandLine.substitutionMap only when the argument CommandLine object (that it is copying from) has a non-null value for CommandLine.substitutionMap. I think this is a CONNECTION_DOES_NOT_NECESSITATE_ORDERING case, given that method-a does not need to be called for method-b to safely execute. Moreover, method-a is a public method that can be called at any point.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-26",
        "inspection-time-in-minutes": 16
    },
    {
        "iid": 5,
        "inspection-start-time": "2022-02-03-01-45",
        "project": "commons-exec",
        "spec-id": "00034",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.addArguments([Ljava/lang/String;)Lorg/apache/commons/exec/CommandLine;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "org.apache.commons.exec.CommandLine",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00034.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddArgumentsArrayNull",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLineTest.java:183",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - method-a was most likely replaced with null?",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testAddArgumentsArrayNull",
        "notes": "In the constructor of CommandLine that the test uses, the return value of method-a is set as the field variable CommandLine.executable; method-b adds an item to the field variable CommandLine.addArgument, which is not related to CommandLine.executable. So, this is most likely a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-49",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 6,
        "inspection-start-time": "2022-02-03-01-49",
        "project": "commons-exec",
        "spec-id": "00035",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.addArguments(Ljava/lang/String;)Lorg/apache/commons/exec/CommandLine;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "org.apache.commons.exec.CommandLine",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00035.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddArguments",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLineTest.java:150",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - Most likely replaced with null?",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testAddArguments",
        "notes": "In the constructor of CommandLine that the test uses, the return value of method-a is set as the field variable CommandLine.executable; method-b adds an item to the field variable CommandLine.addArgument, which is not related to CommandLine.executable. So, this is most likely a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-53",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 7,
        "inspection-start-time": "2022-02-03-01-53",
        "project": "commons-exec",
        "spec-id": "00036",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.addArguments([Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "org.apache.commons.exec.CommandLine",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00036.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddArguments",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLine.java:212",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - Most likely replaced with null?",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testAddArguments",
        "notes": "In the constructor of CommandLine that the test uses, the return value of method-a is set as the field variable CommandLine.executable; method-b adds an item to the field variable CommandLine.addArgument, which is not related to CommandLine.executable. So, this is most likely a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-55",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 8,
        "inspection-start-time": "2022-02-03-01-55",
        "project": "commons-exec",
        "spec-id": "00037",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.addArguments(Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "org.apache.commons.exec.CommandLine",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 4,
        "code-snippets-file": "snippets/ls/00037.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddArguments",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLine.java:197",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - Most likely replaced with null?",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testAddArguments",
        "notes": "In the constructor of CommandLine that the test uses, the return value of method-a is set as the field variable CommandLine.executable; method-b adds an item to the field variable CommandLine.addArgument, which is not related to CommandLine.executable. So, this is most likely a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-57",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 9,
        "inspection-start-time": "2022-02-03-16-29",
        "project": "commons-exec",
        "spec-id": "00048",
        "method-a": "org.apache.commons.exec.DefaultExecuteResultHandler.getException()Lorg/apache/commons/exec/ExecuteException;",
        "method-b": "org.apache.commons.exec.DefaultExecuteResultHandler.getExitValue()I",
        "method-a-return-type": "org.apache.commons.exec.ExecuteException",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00048.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:182",
                        "method-b-site": "DefaultExecutorTest.java:183",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_EXPECTED_OUTPUT - method-a was supposed to return null (and checked via an assertNull()), and DSI replaced the return value of method-a with the default value null.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
        "notes": "While method-a and method-b are stateful because they can both throw exceptions, method-a simply returns the field variable DefaultExecuteResultHandler.exception, and method-b simply returns the field variable DefaultExecuteResultHandler.exitValue. Since these two field variables are not related, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-16-34",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 10,
        "inspection-start-time": "2022-02-03-18-19",
        "project": "commons-exec",
        "spec-id": "00050",
        "method-a": "org.apache.commons.exec.DefaultExecuteResultHandler.onProcessComplete(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecuteResultHandler.hasResult()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00050.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:134",
                        "method-b-site": "DefaultExecuteResultHandler.java:121",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "GOOD_EXAMPLE + STATE_RESTORED: The DefaultExecuteResultHandler.waitFor() (the caller of method-b) makes the thread sleep if method-b returns false. Hence, after sleeping, it calls method-b again, and at that point method-b returns true because the delayed call to method-a happened."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "Commenting out the call to method-a in TutorialTest.java:134, and insert a print statement within the while loop in DefaultExecuteResultHandler.java:122. This will show that not calling method-a before the while loop conditional (the negation of method-b) will result in an infinite while loop.",
        "notes": "method-a sets the field variable DefaultExecuteResultHandler.hasResult to true, and method-b is a 1-line naive getter for that same field variable. While one could call method-b before method-a, it makes sense that method-a *needs* to be called at some point to prevent the caller of method-b from being in an infinite while loop (the caller of method-b is in a loop until method-b returns true). Demote to spurious? since the relationship is more with the caller?",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-18-31",
        "inspection-time-in-minutes": 12
    },
    {
        "iid": 11,
        "inspection-start-time": "2022-02-03-21-29",
        "project": "commons-exec",
        "spec-id": "00055",
        "method-a": "org.apache.commons.exec.DefaultExecuteResultHandler.waitFor(J)V",
        "method-b": "org.apache.commons.exec.ExecuteResultHandler.onProcessComplete(I)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 4,
        "code-snippets-file": "snippets/ls/00055.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testStdInHandling",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:661",
                        "method-b-site": "DefaultExecutor.java:213",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "CONCURRENCY: The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\n a @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:661)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:213)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testStdInHandling",
        "notes": "I'm not sure what exactly the temporal relationship between method-a and method-b should be, because it's almost like they have to happen concurrently in different threads (as the specialized trace suggests). method-a will NOT terminate until method-b is called or unless it hits the timeout, because otherwise its call to hasResult() will be false. Note that method-b may not always be called because the process may fail, in which ExecuteResultHandler.onProcessFailed() will be called. Whatever we decide the relationship will be, this is a super interesting spec/case! GOOD_EXAMPLE (of concurrency). DECISION: I don't think there is a strict temporal relationship here, given that both methods are public, and the design of method-a is in mind that method-b will be called concurrently during the execution of method-a. Additionally, method-a has the timeout, which means that it *will* terminate even without a concurrent call to method-b. DYNAMIC_DISPATCH.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-21-46",
        "inspection-time-in-minutes": 17
    },
    {
        "iid": 12,
        "inspection-start-time": "2022-02-03-21-47",
        "project": "commons-exec",
        "spec-id": "00056",
        "method-a": "org.apache.commons.exec.DefaultExecuteResultHandler.waitFor(J)V",
        "method-b": "org.apache.commons.exec.ExecuteResultHandler.onProcessFailed(Lorg/apache/commons/exec/ExecuteException;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00056.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithError",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:198",
                        "method-b-site": "DefaultExecutor.java:215",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:198)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:215)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testStdInHandling",
        "notes": "GOOD_EXAMPLE + CONCURRENCY: I'm not sure what exactly the temporal relationship between method-a and method-b should be, because it's almost like they have to happen concurrently in different threads (as the specialized trace suggests). method-a will NOT terminate until method-b is called or unless it hits the timeout, because otherwise its call to hasResult() will be false. Note that method-b may not always be called because the process may fail, in which ExecuteResultHandler.onProcessComplete() will be called. Whatever we decide the relationship will be, this is a super interesting spec/case! GOOD_EXAMPLE (of concurrency). DECISION: I don't think there is a strict temporal relationship here, given that both methods are public, and the design of method-a is in mind that method-b will be called concurrently during the execution of method-a. Additionally, method-a has the timeout, which means that it *will* terminate even without a concurrent call to method-b. DYNAMIC_DISPATCH.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-21-51",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 13,
        "inspection-start-time": "2022-02-04-11-40",
        "project": "commons-exec",
        "spec-id": "00060",
        "method-a": "org.apache.commons.exec.DefaultExecuteResultHandler.waitFor()V",
        "method-b": "org.apache.commons.exec.ExecuteResultHandler.onProcessFailed(Lorg/apache/commons/exec/ExecuteException;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00060.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Exec34Test.java:84",
                        "method-b-site": "DefaultExecutor.java:215",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(Exec34Test.java:84)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:215)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testStdInHandling",
        "notes": "GOOD_EXAMPLE + CONCURRENCY: I'm not sure what exactly the temporal relationship between method-a and method-b should be, because it's almost like they have to happen concurrently in different threads (as the specialized trace suggests). method-a will NOT terminate until method-b or one of its other counterparts is called, because otherwise its call to hasResult() will be false. Note that method-b may not always be called because the process may fail, in which ExecuteResultHandler.onProcessComplete() will be called. Whatever we decide the relationship will be, this is a super interesting spec/case! GOOD_EXAMPLE (of concurrency). DECISION: I don't think there is a strict temporal relationship here, given that both methods are public, and the design of method-a is in mind that method-b will be called concurrently during the execution of method-a. However, I think there is a strong idea where either method-b or DefaultExecuteResultHandler.onProcessComplete() needs to be called either before or concurrently with method-a; otherwise, method-a will end in an infinite loop.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-04-11-45",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 14,
        "inspection-start-time": "2022-02-03-21-52",
        "project": "commons-exec",
        "spec-id": "00061",
        "method-a": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00061.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:412",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test still passes because the execution of the script didn't fail, and thus method-b would have returned null regardless of whether method-a was called or not."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "snippet? could try writing a test later, the closing of the input/output/error streams need to fail in order for this true spec to be exposed.",
        "notes": "method-a calls DefaultExecutor.setExceptionCaught() if closing the input/output/errorstreams of the process that was being called failed, which sets the field variable DefaultExecutor.exceptionCaught to the provided IOException. method-b is a 1-line getter for the field variable DefaultExecutor.exceptionCaught (ONE_STATELESS_METHOD). Note that the caller of method-a and method-b also calls DefaultExecutor.setExceptionCaught(), but not while reading the streams; thus, method-a isn't necessarily the only possible place in the code where DefaultExecutor.exceptionCaught is set.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-22-04",
        "inspection-time-in-minutes": 12
    },
    {
        "iid": 15,
        "inspection-start-time": "2022-02-03-22-04",
        "project": "commons-exec",
        "spec-id": "00062",
        "method-a": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00062.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:412",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test does not fail if method-a is commented out"            
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
        "notes": "method-a closes the input, output, and error streams from the process, and sets the field variable DefaultExecutor.exceptionCaught if there were any exceptions from that process. method-b checks the field value DefaultExecutor.exitValues, which is not affected by method-a at all. However, it might be good practice to call method-a before method-b like in this use case, where an exception is immediately thrown if method-b returns true, which would leave the streams (which were supposed to be closed via method-a) open. UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-22-10",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 16,
        "inspection-start-time": "2022-02-03-22-10",
        "project": "commons-exec",
        "spec-id": "00063",
        "method-a": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.Executor.getWorkingDirectory()Ljava/io/File;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.File",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00063.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:412",
                        "method-b-site": "DefaultExecutorTest.java:107",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test does not fail if method-a is commented out"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
        "notes": "method-a closes the input, output, and error streams from the process, and sets the field variable DefaultExecutor.exceptionCaught if there were any exceptions from that process. The only implementation of method-b is a 1-line naive getter to the field value DefaultExecutor.workingDirectory, which is not affected by method-a at all (ONE_STATELESS_METHOD). Hence, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-22-14",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 17,
        "inspection-start-time": "2022-02-03-22-14",
        "project": "commons-exec",
        "spec-id": "00064",
        "method-a": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00064.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:412",
                        "method-b-site": "DefaultExecutorTest.java:106",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test does not fail if method-a is commented out"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
        "notes": "method-a closes the input, output, and error streams from the process, and sets the field variable DefaultExecutor.exceptionCaught if there were any exceptions from that process. The only implementation of method-b checks the field value DefaultExecutor.exitValues, which is not affected by method-a at all. Hence, this is a spurious spec. UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-22-19",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 18,
        "inspection-start-time": "2022-02-04-00-22",
        "project": "commons-exec",
        "spec-id": "00065",
        "method-a": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00065.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:222",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "CONCURRENCY: The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:222)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:412)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "GOOD_EXAMPLE: method-a creates a new thread that calls the caller of method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a. SPECIAL_NBP + CONCURRENCY",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-00-41",
        "inspection-time-in-minutes": 19
    },
    {
        "iid": 19,
        "inspection-start-time": "2022-02-04-11-45",
        "project": "commons-exec",
        "spec-id": "00066",
        "method-a": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00066.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:222",
                        "method-b-site": "DefaultExecutor.java:47",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:222)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:47)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this? Also, the tracked call site of method-b is the declaration of the DefaultExecutor class... how did this happen? INSPECTION_TODO"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates a new thread that calls method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-11-55",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 20,
        "inspection-start-time": "2022-02-04-11-55",
        "project": "commons-exec",
        "spec-id": "00067",
        "method-a": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00067.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:222",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:222)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:414)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates a new thread that calls the caller of method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-12-08",
        "inspection-time-in-minutes": 13
    },
    {
        "iid": 21,
        "inspection-start-time": "2022-02-04-12-17",
        "project": "commons-exec",
        "spec-id": "00070",
        "method-a": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 11,
        "code-snippets-file": "snippets/ls/00070.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:222",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:222)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:431)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "method-a creates a new thread that calls the caller of method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a. SPECIAL_NBP + CONCURRENCY",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-12-24",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 22,
        "inspection-start-time": "2022-02-04-12-25",
        "project": "commons-exec",
        "spec-id": "00071",
        "method-a": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00071.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:222",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:222)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:351)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates a new thread that calls the caller of method-b (which runs an internal process), so in some sense this is a nbp? Not sure how to categorize this, but it seems that method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-12-27",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 23,
        "inspection-start-time": "2022-02-04-22-53",
        "project": "commons-exec",
        "spec-id": "00093",
        "method-a": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00093.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:186",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:186)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:412)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a creates and starts new thread that calls the caller of method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-22-59",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 24,
        "inspection-start-time": "2022-02-04-23-06",
        "project": "commons-exec",
        "spec-id": "00095",
        "method-a": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00095.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:186",
                        "method-b-site": "DefaultExecutor.java:47",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:186)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:47)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this? Note that the call site of method-b is incorrect; the stated call site of method-b points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates and starts new thread that calls method-b, so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-23-10",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 25,
        "inspection-start-time": "2022-02-04-23-10",
        "project": "commons-exec",
        "spec-id": "00096",
        "method-a": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00096.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:186",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:186)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:414)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates and starts new thread that calls the caller of method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-23-14",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 26,
        "inspection-start-time": "2022-02-04-23-24",
        "project": "commons-exec",
        "spec-id": "00099",
        "method-a": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00099.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:186",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:186)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:431)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates and starts new thread that calls the caller of method-b (which runs an internal process), so in some sense this is a nbp? Not sure how to categorize this, but it seems that method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-23-28",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 27,
        "inspection-start-time": "2022-02-04-23-28",
        "project": "commons-exec",
        "spec-id": "00100",
        "method-a": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00100.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:186",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:186)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:351)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a creates and starts new thread that calls the caller of method-b (which runs an internal process), so this is a special kind of NBP. method-b will not be called if method-a is not called because the Runnable object that calls method-b is passed into method-a.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-23-30",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 28,
        "inspection-start-time": "2022-02-04-23-45",
        "project": "commons-exec",
        "spec-id": "00108",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "java.io.IOException",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00108.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:414",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_CORRECT_VALUE_NONASSERTION: method-a would return null on a normal execution (because the test does not expect an IOException to be thrown), and DSI replaced the return value of method-a with null.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
        "notes": "ONE_STATELESS_METHOD - method-a is a 1-line naive getter for the field variable DefaultExecutor.exceptionCaught, and method-b does not access or modify that field variable.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-23-51",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 29,
        "inspection-start-time": "2022-02-04-23-51",
        "project": "commons-exec",
        "spec-id": "00109",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-b": "org.apache.commons.exec.Executor.getWorkingDirectory()Ljava/io/File;",
        "method-a-return-type": "java.io.IOException",
        "method-b-return-type": "java.io.File",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00109.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:414",
                        "method-b-site": "DefaultExecutorTest.java:107",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_CORRECT_VALUE_NONASSERTION: method-a would return null on a normal execution (because the test does not expect an IOException to be thrown), and DSI replaced the return value of method-a with null.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "UNRELATED_STATELESS_METHODS - method-a is a 1-line naive getter to the field variable DefaultExecutor.exceptionCaught, and method-b is a 1-line naive getter to the field variable DefaultExecutor.workingDirectory.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-04-23-59",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 30,
        "inspection-start-time": "2022-02-04-23-59",
        "project": "commons-exec",
        "spec-id": "00110",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-b": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-a-return-type": "java.io.IOException",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00110.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:414",
                        "method-b-site": "DefaultExecutorTest.java:459",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_CORRECT_VALUE_NONASSERTION: method-a would return null on a normal execution (because the test does not expect an IOException to be thrown), and DSI replaced the return value of method-a with null.",
                "notes": "EXPECTED_EXCEPTION - the caller of method-a (DefaultExecutor.executeInternal()) is expected to throw an ExecuteException because the process that it runs exits on an excit code (1) that is recognized as indicating that the process failed (and DefaultExecutor.executeInternal() throws an ExecuteException on DefaultExecutor.java:432 when this happens). method-b double checks that the exit value ."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
        "notes": "ONE_STATELESS_METHOD - method-a is a 1-line naive getter for the field variable DefaultExecutor.exceptionCaught, and method-b does not access or modify that field variable.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-00-10",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 31,
        "inspection-start-time": "2022-02-05-00-10",
        "project": "commons-exec",
        "spec-id": "00111",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00111.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:223",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:223)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:412)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet/reasoning below.",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: If the sanity checks had passed and the DSI experiment happened, I'm sure that this would have resulted in a stage-0-failure. This is because DefaultExecutor.createThread() sets the field variable DefaultExecutor.executorThread to be a Thread object containing the Runnable object that calls method-b. method-a is necessary so that that specific Runnable can be retrieved and run - if method-a was not called, method-b would not be called (because the thread is set to run the caller of method-b). method-b closes the streams for the Process, so it wouldn't make sense to call method-b before method-a either. Not sure if this would hold in a general sense though, I feel like this is almost a nbp.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-00-23",
        "inspection-time-in-minutes": 13
    },
    {
        "iid": 32,
        "inspection-start-time": "2022-02-05-02-15",
        "project": "commons-exec",
        "spec-id": "00112",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00112.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:223",
                        "method-b-site": "DefaultExecutor.java:47",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:223)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:47)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this? Note that the call site to method-b specified as above is incorrect; the line is pointing to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet/reasoning below.",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: If the sanity checks had passed and the DSI experiment happened, I'm sure that this would have resulted in a stage-0-failure. This is because DefaultExecutor.createThread() sets the field variable DefaultExecutor.executorThread to be a Thread object containing the Runnable object that calls method-b. method-a is necessary so that that specific Runnable can be retrieved and run - if method-a was not called, method-b would not be called (because the thread is set to run the caller of method-b). method-b runs the specific process that method-a retrieves, and it seems like the use case necessitates creating a new Thread to run method-b on, and having method-a retrieve that Thread. Not sure if this spec would hold in a general sense though, I feel like this is almost a nbp.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-02-20",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 33,
        "inspection-start-time": "2022-02-05-02-20",
        "project": "commons-exec",
        "spec-id": "00113",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00113.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:223",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:223)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:414)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet/reasoning below.",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: If the sanity checks had passed and the DSI experiment happened, I'm sure that this would have resulted in a stage-0-failure. This is because DefaultExecutor.createThread() sets the field variable DefaultExecutor.executorThread to be a Thread object containing the Runnable object that indirectly calls method-b. method-a is necessary so that that specific Runnable can be retrieved and run - if method-a was not called, method-b would not be called (because the thread is set to run the caller of method-b). method-b retrieves the field variable DefaultExecutor.exceptionCaught, which is set by methods called by the caller of method-b, so it wouldn't make sense to call method-b before method-a either. Not sure if this would hold in a general sense though, I feel like this is almost a nbp. Also, given the definition of these two methods, it seems that this could also be considered as UNRELATED_STATELESS_METHODS.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-02-25",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 34,
        "inspection-start-time": "2022-02-05-02-25",
        "project": "commons-exec",
        "spec-id": "00115",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 11,
        "code-snippets-file": "snippets/ls/00115.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:223",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:223)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:431)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet/reasoning below.",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: If the sanity checks had passed and the DSI experiment happened, I'm sure that this would have resulted in a stage-0-failure. This is because DefaultExecutor.createThread() sets the field variable DefaultExecutor.executorThread to be a Thread object containing the Runnable object that indirectly calls method-b. method-a is necessary so that that specific Runnable can be retrieved and run - if method-a was not called, method-b would not be called (because the thread is set to run the caller of method-b). method-b performs checks on either the field value DefaultExecutor.exitValues or the argument exitValue (which is only retrieved from after the process is run), so it wouldn't make sense to call method-b before method-a either. Not sure if this relationship would hold in a general sense though, but I feel like this is almost a nbp.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-02-30",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 35,
        "inspection-start-time": "2022-02-05-02-30",
        "project": "commons-exec",
        "spec-id": "00116",
        "method-a": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "code-snippets-file": "snippets/ls/00116.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:223",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of the concurrency issue; the Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:223)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:351)\n, so I think \"ab\" was not satisfied specifically because the Thd values were different. Should we expand our definition of \"satisfying the property\" to allow cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet/reasoning below.",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: If the sanity checks had passed and the DSI experiment happened, I'm sure that this would have resulted in a stage-0-failure. This is because DefaultExecutor.createThread() sets the field variable DefaultExecutor.executorThread to be a Thread object containing the Runnable object that indirectly calls method-b. method-a is necessary so that that specific Runnable can be retrieved and run - if method-a was not called, method-b would not be called (because the thread is set to run the caller of method-b). method-b actually creates the process and runs the command, so it wouldn't make sense to call method-b before method-a either. Not sure if this relationship would hold in a general sense though, but I feel like this is almost a nbp.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-02-37",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 36,
        "inspection-start-time": "2022-02-05-02-52",
        "project": "commons-exec",
        "spec-id": "00118",
        "method-a": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-b": "org.apache.commons.exec.Executor.getWorkingDirectory()Ljava/io/File;",
        "method-a-return-type": "boolean",
        "method-b-return-type": "java.io.File",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00118.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:431",
                        "method-b-site": "DefaultExecutorTest.java:107",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_CORRECT_VALUE_NONASSERTION - method-a in a normal run returns false, and DSI replaced the return value of method-a with the default value false.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "ONE_STATELESS_METHOD - method-b is a 1-line naive getter for the field variable DefaultExecutor.workingDirectory, which is not accessed nor modified by method-a. Hence, this is a spurious-spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-02-58",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 37,
        "inspection-start-time": "2022-02-05-04-13",
        "project": "commons-exec",
        "spec-id": "00126",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00126.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "method-a sets the field variable DefaultExecutor.exitValues, and method-b closes all streams with respect to a given Process value. These two methods are unrelated.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-04-17",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 38,
        "inspection-start-time": "2022-02-05-12-37",
        "project": "commons-exec",
        "spec-id": "00129",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00129.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: the critical point at which method-a ought to be called is DefaultExecutor.java:431. Since method-b is called before that point, the delayed call to method-a happened, and the state was restored."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "ONE_STATELESS_METHOD - method-b is a 1-line naive getter for the field variable DefaultExecutor.exceptionCaught, and method-a is a setter for the field variable DefaultExecutor.setExitValues; the value set by calling method-a does not impact the return value of method-b. Hence, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-12-43",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 39,
        "inspection-start-time": "2022-02-05-13-05",
        "project": "commons-exec",
        "spec-id": "00131",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00131.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: the critical point at which method-a ought to be called is DefaultExecutor.java:431. Since method-b is called before that point, the delayed call to method-a happened, and the state was restored. INSPECTION_TODO: point to this line 431 in the snippet."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "method-a is a (non-pure) setter to the field variable DefaultExecutor.exitValues (the series of valid exit values for the process to be considered as exited successfully), and method-b creates a process to run the command (it doesn't access or modify DefaultExecutor.exitValues). DefaultExecutor.exitValues is only needed to evaluate the result of the process, so one *could* call method-a after method-b is called as long as it is before the point at which the exit value of that launched process is evaluated (DefaultExecutor.java:431).",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-13-10",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 40,
        "inspection-start-time": "2022-02-05-13-31",
        "project": "commons-exec",
        "spec-id": "00133",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-b": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00133.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "DefaultExecutorTest.java:459",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test passes because it checks that an exit code value (1) indicates a failure; this value is neither set by method-a to be a valid exit value, nor is it a valid exit value according to the OS default (ex. 0 is the default valid exit value). EXPECTED_EXCEPTION is thrown regardless of what the exit status is, and calling `a` after `b` in the catch clause is okay! This is a really weak test."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "snippet?",
        "notes": "method-a is a (non-pure) setter for the field variable DefaultExecutor.exitValues, and the implementation of method-b uses that field variable to determine whether the argument exit code signifies that the process exited successfully. Note that the constructor of DefaultExecutor sets DefaultExecutor.exitValues to an empty int array, so one can technically call method-b without having called method-a at all.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-13-40",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 41,
        "inspection-start-time": "2022-02-05-13-40",
        "project": "commons-exec",
        "spec-id": "00134",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-b": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00134.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "TutorialTest.java:106",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: the point at which method-a needs to be called for the test to succeed is by TutorialTest.java:117. Since method-b is called before that point, the delayed call to method-a happened and the state was restored. INSPECTION_TODO: point to this line 117 in the snippet."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample",
        "notes": "UNRELATED_STATEFUL_METHODS/ONE_PURE_SETTER: method-a is a (non-pure) setter that sets the field variable DefaultExecutor.exitValues, and method-b is a pure setter to the field variable DefaultExecutor.watchdog. Since these two field variables don't affect each other, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-13-49",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 42,
        "inspection-start-time": "2022-02-05-16-08",
        "project": "commons-exec",
        "spec-id": "00142",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00142.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:51",
                        "method-b-site": "Exec65Test.java:52",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Technically EXPECTED_EXCEPTION, but not related to the DSI experiment."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
        "notes": "UNRELATED_PURE_SETTERS: method-a is a pure setter to the field variable DefaultExecutor.streamHandler, and method-b is a pure setter to the field variable DefaultExecutor.watchdog. These two variables are unrelated and have different types, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-16-10",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 43,
        "inspection-start-time": "2022-02-05-17-17",
        "project": "commons-exec",
        "spec-id": "00154",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00154.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Exec41Test.java:76",
                        "method-b-site": "Exec41Test.java:77",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
        "notes": "UNRELATED_PURE_SETTERS - method-a is a pure setter to the field variable DefaultExecutor.watchdog, and method-b is a pure setter to the field variable DefaultExecutor.setStreamHandler. Note that this spec is a reversal of 00142, which is also a spurious spec. Can we possibly leverage this insight? GOOD_EXAMPLE INSIGHT!",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-20",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 44,
        "inspection-start-time": "2022-02-05-17-20",
        "project": "commons-exec",
        "spec-id": "00155",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00155.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, which is what the constructor of DefaultExecutor sets DefaultExecutor.workingDirectory to. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.workingDirectory, and method-b closes the input/output/error streams from the subprocess after it has terminated/been killed. method-b does not use and is not affected by the field variable set by method-a, so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-27",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 45,
        "inspection-start-time": "2022-02-05-17-27",
        "project": "commons-exec",
        "spec-id": "00156",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00156.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, even when the constructor of the DefaultExecutor class has already set the working directory to the current directory. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.workingDirectory. That field variable is passed into method-b as a final argument dir (which means that calling method-a within method-b would not change the value of dir). Since method-b uses this dir argument to start the process in the directory specified, it seems fair to conclude that this is a SOMETIMES_TRUE_SPEC for the case when one would want to call the process from a different working directory from the current one (the constructor of DefaultExecutor sets the field variable DefaultExecutor.workingDirectory to the current directory). DECISION: Since the field variable DefaultExecutor.workingDirectory is set to a default value in the constructor of DefaultExecutor, and method-a is a public method that can be called at any point, this is more likely a spurious spec than a sometimes true spec (CONNECTION_DOES_NOT_NECESSITATE_ORDERING). A user can call method-a before method-b to change the directory in which the process that method-b would run, but the user does not have to as well. Even if we attempted to encode this in JavaMOP, I don't think we can automatically infer the situations in which method-a ought to be called, which means this will not be a helpful spec for JavaMOP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-39",
        "inspection-time-in-minutes": 12
    },
    {
        "iid": 46,
        "inspection-start-time": "2022-02-05-17-39",
        "project": "commons-exec",
        "spec-id": "00157",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00157.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutorTest.java:559",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, even when the constructor of the DefaultExecutor class has already set the working directory to the current directory. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "REVISIT - construct the example test. If I'm right, all one needs to do is to write a script that outputs the current directory, and do an assertEquals on baos",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.workingDirectory. method-b (indirectly) uses this field variable to launch the subprocess in the specified working directory, or throw an IOException in the case that either DefaultExecutor.workingDirectory is null, or it points to a nonexisting directory. DECISION: Since the field variable DefaultExecutor.workingDirectory is set to a default value in the constructor of DefaultExecutor, and method-a is a public method that can be called at any point, this is more likely a spurious spec than a sometimes true spec (CONNECTION_DOES_NOT_NECESSITATE_ORDERING). A user can call method-a before method-b to change the directory in which the process that method-b would run, but the user does not have to as well. Even if we attempted to encode this in JavaMOP, I don't think we can automatically infer the situations in which method-a ought to be called, which means this will not be a helpful spec for JavaMOP.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-17-43",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 47,
        "inspection-start-time": "2022-02-05-17-43",
        "project": "commons-exec",
        "spec-id": "00158",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00158.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, even when the constructor of the DefaultExecutor class has already set the working directory to the current directory. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.workingDirectory. method-b (indirectly) uses this field variable to launch the subprocess in the specified working directory, or throw an IOException in the case that either DefaultExecutor.workingDirectory is null, or it points to a nonexisting directory. DECISION: Since the field variable DefaultExecutor.workingDirectory is set to a default value in the constructor of DefaultExecutor, and method-a is a public method that can be called at any point, this is more likely a spurious spec than a sometimes true spec (CONNECTION_DOES_NOT_NECESSITATE_ORDERING). A user can call method-a before method-b to change the directory in which the process that method-b would run, but the user does not have to as well. Even if we attempted to encode this in JavaMOP, I don't think we can automatically infer the situations in which method-a ought to be called, which means this will not be a helpful spec for JavaMOP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-45",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 48,
        "inspection-start-time": "2022-02-05-17-45",
        "project": "commons-exec",
        "spec-id": "00159",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00159.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, even when the constructor of the DefaultExecutor class has already set the working directory to the current directory. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER + ONE_STATELESS_METHOD; method-a is a pure setter for the field variable DefaultExecutor.workingDirectory, and method-b is a 1-line naive getter for the field variable DefaultExecutor.exceptionCaught.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-48",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 49,
        "inspection-start-time": "2022-02-05-17-48",
        "project": "commons-exec",
        "spec-id": "00160",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00160.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, even when the constructor of the DefaultExecutor class has already set the working directory to the current directory. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.workingDirectory, and method-b checks the exit value retrieved from the subprocess after it terminated/got killed using the field variable DefaultExecutor.exitValues. Although DefaultExecutor.workingDirectory is needed for launching the subprocess in the first place, the constructor of DefaultExecutor sets the field variable to the current directory. In a very loose sense, not setting method-a before launching the process might cause the script to fail if its success/failure depends on its working directory, but even then, the critical point would be the execution of the process, not the post-process checking that method-b does.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-51",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 50,
        "inspection-start-time": "2022-02-05-17-52",
        "project": "commons-exec",
        "spec-id": "00161",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00161.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION; while the expected exception is thrown by method-b, it is not related to the interaction between method-a and method-b. The test itself is weak for the purposes of running DSI on this spec because method-a is essentially a no-op; the call to method-a sets the working directory to the current directory, even when the constructor of the DefaultExecutor class has already set the working directory to the current directory. Plus, the script that the test calls is not dependent on its working directory (it simply prints out some variable values)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "method-a is a pure setter for the field variable DefaultExecutor.workingDirectory. The caller of method-b takes in DefaultExecutor.workingDirectory (in all invocations) as the final argument dir, and passes it in to method-b. method-b creates and launches a new subprocess for the specified command. Given that method-b is using the field value dir, one might think that method-a must be called before method-b when one wants to use a working directory other than the current one (the constructor of DefaultExecutor sets the field variable DefaultExecutor.workingDirectory to the current directory). However, method-b is actually already too late, since the variable dir is final within the caller of method-b. So, one must call method-a before calling the caller of method-b, is the precise spec here. However, this \"transitively\" means that method-a must be called before calling method-b, so I'm not sure how to categorize this spec. DECISION: method-b is protected, so one can create a subclass that calls method-b with a File that is not DefaultExecutor.workingDirectory",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-17-57",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 51,
        "inspection-start-time": "2022-02-06-17-57",
        "project": "commons-exec",
        "spec-id": "00162",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00162.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:557",
                        "method-b-site": "DefaultExecutorTest.java:558",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test does not fail if method-a is commented out"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "UNRELATED_PURE_SETTERS: method-a is a pure setter to the field variable DefaultExecutor.workingDirectory, and method-b is a pure setter to the field variable DefaultExecutor.streamHandler.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-18-00",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 52,
        "inspection-start-time": "2022-02-06-18-00",
        "project": "commons-exec",
        "spec-id": "00163",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00163.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:347",
                        "method-b-site": "DefaultExecutorTest.java:349",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test does not fail is method-a is commented out."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "UNRELATED_PURE_SETTERS: method-a is a pure setter to the field variable DefaultExecutor.workingDirectory, and method-b is a pure setter to the field variable DefaultExecutor.watchdog.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-18-03",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 53,
        "inspection-start-time": "2022-02-05-18-08",
        "project": "commons-exec",
        "spec-id": "00166",
        "method-a": "org.apache.commons.exec.ExecuteResultHandler.onProcessComplete(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecuteResultHandler.getException()Lorg/apache/commons/exec/ExecuteException;",
        "method-a-return-type": "void",
        "method-b-return-type": "org.apache.commons.exec.ExecuteException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00166.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:213",
                        "method-b-site": "DefaultExecutorTest.java:182",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:182)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:213)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on DefaultExecutorTest.java:181 would fail if method-a was not called by that point. INSPECTION_TODO."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables DefaultExecuteResultHandler.exitValue, DefaultExecuteResultHandler.exception, and DefaultExecuteResultHandler.hasResult. method-b checks the field variables DefaultExecuteResultHandler.hasResult, and either throws an exception or returns the value of the field variable DefaultExecuteResultHandler.exception. Since both of these field variables are set by method-a, method-a ought to be called before method-b (in the case that the process completed without failure). This is a SOMETIMES_TRUE_SPEC because the process may fail, in which case ExecuteResultHandler.onProcessFailed() is called instead. So, I think both of these specs can be combined to create a larger spec?",
        "findings": "The JavaMOP spec for this one would look like: \"[](method-b ==> (*) (method-a |  ExecuteResultHandler.onProcessFailed())",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-18-26",
        "inspection-time-in-minutes": 26
    },
    {
        "iid": 54,
        "inspection-start-time": "2022-02-05-20-35",
        "project": "commons-exec",
        "spec-id": "00167",
        "method-a": "org.apache.commons.exec.ExecuteResultHandler.onProcessComplete(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecuteResultHandler.getExitValue()I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 4,
        "code-snippets-file": "snippets/ls/00167.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:213",
                        "method-b-site": "DefaultExecutorTest.java:183",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:183)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:213)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on DefaultExecutorTest.java:181 would fail if method-a was not called by that point. INSPECTION_TODO."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables DefaultExecuteResultHandler.exitValue, DefaultExecuteResultHandler.exception, and DefaultExecuteResultHandler.hasResult. method-b checks the field variables DefaultExecuteResultHandler.hasResult, and either throws an exception or returns the value of the field variable DefaultExecuteResultHandler.exitValue. Since both of these field variables are set by method-a, method-a ought to be called before method-b (in the case that the process completed without failure). This is a SOMETIMES_TRUE_SPEC because the process may fail, in which case ExecuteResultHandler.onProcessFailed() is called instead. So, I think both of these specs can be combined to create a larger spec?",
        "findings": "The JavaMOP spec for this one would look like: \"[](method-b ==> (*) (method-a |  ExecuteResultHandler.onProcessFailed())",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-20-43",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 55,
        "inspection-start-time": "2022-02-05-20-46",
        "project": "commons-exec",
        "spec-id": "00168",
        "method-a": "org.apache.commons.exec.ExecuteResultHandler.onProcessFailed(Lorg/apache/commons/exec/ExecuteException;)V",
        "method-b": "org.apache.commons.exec.DefaultExecuteResultHandler.getException()Lorg/apache/commons/exec/ExecuteException;",
        "method-a-return-type": "void",
        "method-b-return-type": "org.apache.commons.exec.ExecuteException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00168.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:215",
                        "method-b-site": "DefaultExecutorTest.java:522",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:522)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:215)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on DefaultExecutorTest.java:181 would fail if method-a was not called by that point. INSPECTION_TODO."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables DefaultExecuteResultHandler.exitValue, DefaultExecuteResultHandler.exception, and DefaultExecuteResultHandler.hasResult. method-b checks the field variables DefaultExecuteResultHandler.hasResult, and either throws an exception or returns the value of the field variable DefaultExecuteResultHandler.exception. Since both of these field variables are set by method-a, method-a ought to be called before method-b (in the case that the process completed without failure). This is a SOMETIMES_TRUE_SPEC because the process may instead complete normally without failing, in which case ExecuteResultHandler.onProcessComplete() is called instead. So, I think both of these specs can be combined to create a larger spec?",
        "findings": "The JavaMOP spec for this one would look like: \"[](method-b ==> (*) (method-a |  ExecuteResultHandler.onProcessComplete())",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-20-53",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 56,
        "inspection-start-time": "2022-02-05-20-53",
        "project": "commons-exec",
        "spec-id": "00169",
        "method-a": "org.apache.commons.exec.ExecuteResultHandler.onProcessFailed(Lorg/apache/commons/exec/ExecuteException;)V",
        "method-b": "org.apache.commons.exec.DefaultExecuteResultHandler.getExitValue()I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00169.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithError",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:215",
                        "method-b-site": "DefaultExecutorTest.java:200",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:200)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:215)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on DefaultExecutorTest.java:181 would fail if method-a was not called by that point. INSPECTION_TODO."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables DefaultExecuteResultHandler.exitValue, DefaultExecuteResultHandler.exception, and DefaultExecuteResultHandler.hasResult. method-b checks the field variables DefaultExecuteResultHandler.hasResult, and either throws an exception or returns the value of the field variable DefaultExecuteResultHandler.exitValue. Since both of these field variables are set by method-a, method-a ought to be called before method-b (in the case that the process completed without failure). This is a SOMETIMES_TRUE_SPEC because the process may instead complete normally without failing, in which case ExecuteResultHandler.onProcessComplete() is called instead. So, I think both of these specs can be combined to create a larger spec?",
        "findings": "The JavaMOP spec for this one would look like: \"[](method-b ==> (*) (method-a |  ExecuteResultHandler.onProcessComplete())",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-20-56",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 57,
        "inspection-start-time": "2022-02-05-20-56",
        "project": "commons-exec",
        "spec-id": "00176",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessInputStream(Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.setProcessErrorStream(Ljava/io/InputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "code-snippets-file": "snippets/ls/00176.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:361",
                        "method-b-site": "DefaultExecutor.java:363",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED - note that DefaultExecutor.java:372 is the critical point by which both method-a and method-b need to be called; since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "The implementation of method-a modifies the field variable PumpStreamHandler.inputThread, and the implementation of method-b modifies the field variable PumpStreamHandler.errorThread (neither of them are pure setters). Since these two field variables by themselves are not related to each other (PumpStreamHandler.inputThread is a handle on the process's input stream, and PumpStreamHandler.errorThread is a handle on the process's error output stream), this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-22-06",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 58,
        "inspection-start-time": "2022-02-05-22-06",
        "project": "commons-exec",
        "spec-id": "00177",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessInputStream(Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.setProcessOutputStream(Ljava/io/InputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "code-snippets-file": "snippets/ls/00177.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:361",
                        "method-b-site": "DefaultExecutor.java:362",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED - note that DefaultExecutor.java:372 is the critical point by which both method-a and method-b need to be called; since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "The implementation of method-a modifies the field variable PumpStreamHandler.inputThread, and the implementation of method-b modifies the field variable PumpStreamHandler.outputThread (neither of the methods are pure setters). Since these two field variables by themselves are not related to each other (PumpStreamHandler.inputThread is a handle on the process's input stream, and PumpStreamHandler.outputThread is a handle on the process's output stream), this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-22-08",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 59,
        "inspection-start-time": "2022-02-05-22-37",
        "project": "commons-exec",
        "spec-id": "00180",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessInputStream(Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.PumpStreamHandler.createProcessErrorPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00180.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:361",
                        "method-b-site": "PumpStreamHandler.java:129",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED - note that DefaultExecutor.java:372 is the critical point by which both method-a and method-b need to be called; since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "The implementation of method-a modifies the field variable PumpStreamHandler.inputThread, and method-b modifies the field variable PumpStreamHandler.errorThread (neither method is a pure setter). Since these two field variables are not related to each other (PumpStreamHandler.inputThread is a handle on the process's input stream, and PumpStreamHandler.errorThread is a handle on the process's error output stream), this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-22-39",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 60,
        "inspection-start-time": "2022-02-05-22-39",
        "project": "commons-exec",
        "spec-id": "00181",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessInputStream(Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.PumpStreamHandler.createProcessOutputPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00181.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:361",
                        "method-b-site": "PumpStreamHandler.java:116",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED - note that DefaultExecutor.java:372 is the critical point by which both method-a and method-b need to be called; since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "The implementation of method-a modifies the field variable PumpStreamHandler.inputThread, and method-b modifies the field variable PumpStreamHandler.outputThread (neither method is a pure setter). Since these two field variables are not related to each other (PumpStreamHandler.inputThread is a handle on the process's input stream, and PumpStreamHandler.errorThread is a handle on the process's error output stream), this is a spurious spec - UNRELATED_STATEFUL_METHODS. INSPECTION_TODO: it looks like this comment is repeated from the previous spec",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-22-42",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 61,
        "inspection-start-time": "2022-02-05-22-45",
        "project": "commons-exec",
        "spec-id": "00184",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessOutputStream(Ljava/io/InputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.setProcessErrorStream(Ljava/io/InputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "code-snippets-file": "snippets/ls/00184.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:362",
                        "method-b-site": "DefaultExecutor.java:363",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED - note that DefaultExecutor.java:372 is the critical point by which both method-a and method-b need to be called; since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "The implementation of method-a modifies the field variable PumpStreamHandler.outputThread, and the implementation of method-b modifies the field variable PumpStreamHandler.errorThread (neither method is a pure setter). Since these two field variables by themselves are not related to each other (PumpStreamHandler.outputThread is a handle on the process's output stream, and PumpStreamHandler.errorThread is a handle on the process's error output stream), this is a spurious spec - UNRELATED_STATEFUL_METHODS. INSPECTION_TODO: it looks like this comment is repeated from the previous specs",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-22-47",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 62,
        "inspection-start-time": "2022-02-05-23-03",
        "project": "commons-exec",
        "spec-id": "00187",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessOutputStream(Ljava/io/InputStream;)V",
        "method-b": "org.apache.commons.exec.PumpStreamHandler.createProcessErrorPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00187.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:362",
                        "method-b-site": "PumpStreamHandler.java:129",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED - note that DefaultExecutor.java:372 is the critical point by which both method-a and method-b need to be called; since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "The implementation of method-a modifies the field variable PumpStreamHandler.outputThread, and method-b modifies the field variable PumpStreamHandler.errorThread (neither method is a pure setter). Since these two field variables by themselves are not related to each other (PumpStreamHandler.outputThread is a handle on the process's output stream, and PumpStreamHandler.errorThread is a handle on the process's error output stream), this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-23-06",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 63,
        "inspection-start-time": "2022-02-05-23-36",
        "project": "commons-exec",
        "spec-id": "00194",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00194.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:420",
                        "method-b-site": "ExecuteWatchdog.java:209",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:209)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on Exec34Test.java:85 would fail if method-a was not called by that point. INSPECTION_TODO: make sure that the line 85 is clearly marked in the snippet."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet?",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a checks for the field variable ExecuteWatchdog.caught, and throws it if its value is not null. method-b checks for the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught to see whether the process is started or not already terminated. While both methods access ExecuteWatchdog.caught, I don't think it necessitates method-a being called before method-b - CONNECTION_DOES_NOT_NECESSITATE_ORDERING.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-23-50",
        "inspection-time-in-minutes": 24
    },
    {
        "iid": 64,
        "inspection-start-time": "2022-02-05-23-50",
        "project": "commons-exec",
        "spec-id": "00195",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.isWatching()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00195.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:420",
                        "method-b-site": "Exec34Test.java:88",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:88)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on Exec34Test.java:85 would fail if method-a was not called by that point. INSPECTION_TODO."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet?",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a checks for the field variable ExecuteWatchdog.caught, and throws it if its value is not null. method-b checks whether the watchdog is still monitoring the process via checking the field variables ExecuteWatchdog.processStarted, ExecuteWatchdog.caught, and ExecuteWatchdog.watch. While both methods access ExecuteWatchdog.caught, I don't think that necessitates method-a being called before method-b - CONNECTION_DOES_NOT_NECESSITATE_ORDERING.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-23-54",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 65,
        "inspection-start-time": "2022-02-05-23-55",
        "project": "commons-exec",
        "spec-id": "00196",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00196.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:420",
                        "method-b-site": "Exec34Test.java:87",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:87)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. It is weird to me that the test didn't fail in the sanity check run where it records method-b being called before method-a, since the assertion on Exec34Test.java:85 would fail if method-a was not called by that point. INSPECTION_TODO."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet?",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a checks for the field variable ExecuteWatchdog.caught, and throws it if its value is not null. ONE_STATELESS_METHOD: method-b is a 1-line naive getter for the field variable ExecuteWatchdog.killedProcess. These field variables are not temporaly related, so this a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-23-58",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 66,
        "inspection-start-time": "2022-02-05-23-59",
        "project": "commons-exec",
        "spec-id": "00198",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00198.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:181",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\na @ Thd[31]Obj[0]:0(ExecuteWatchdog.java:181)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process, while method-b checks for the field variable ExecuteWatchdog.caught (a Throwable object), and throws it if it's not null. Since these field variables are not directly related, I think this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-00-37",
        "inspection-time-in-minutes": 38
    },
    {
        "iid": 67,
        "inspection-start-time": "2022-02-06-00-37",
        "project": "commons-exec",
        "spec-id": "00199",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00199.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:181",
                        "method-b-site": "ExecuteWatchdog.java:209",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(ExecuteWatchdog.java:209)\na @ Thd[31]Obj[0]:0(ExecuteWatchdog.java:181)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process, while method-b checks the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught to ensure that either the process is started or not already terminated. Since these field variables are not directly related, I think this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-00-44",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 68,
        "inspection-start-time": "2022-02-06-00-45",
        "project": "commons-exec",
        "spec-id": "00200",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.isWatching()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00200.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:181",
                        "method-b-site": "Exec34Test.java:88",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(Exec34Test.java:88)\na @ Thd[31]Obj[0]:0(ExecuteWatchdog.java:181)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process. method-b checks the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught to ensure that either the process is started or not already terminated, and then returns the field variable ExecuteWatchdog.watch. However, since method-a sets the field variable ExecuteWatchdog.watch to false, and it seems like this particular use case was just the test checking that method-a made ExecuteWatchdog.watch to false, I don't think this is a true spec? Although, this may be another kind of \"b* a b*\" kind of spec instead. Potentially MORE_COMPLEX_THAN_AB DECISION: one can cleanup or check watch at anytime without also doing the other. CONNECTION_DOES_NOT_NECESSITATE_ORDERING",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-00-50",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 69,
        "inspection-start-time": "2022-02-06-01-03",
        "project": "commons-exec",
        "spec-id": "00201",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00201.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:181",
                        "method-b-site": "Exec34Test.java:87",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(Exec34Test.java:87)\na @ Thd[31]Obj[0]:0(ExecuteWatchdog.java:181)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process, while method-b is a 1-line naive getter for the field variable ExecuteWatchdog.killedProcess (ONE_STATELESS_METHOD). Since these field variables are not directly related, I think this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-20-06-01-06",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 70,
        "inspection-start-time": "2022-02-06-01-06",
        "project": "commons-exec",
        "spec-id": "00202",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00202.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:181",
                        "method-b-site": "DefaultExecutor.java:402",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:402)\na @ Thd[31]Obj[0]:0(ExecuteWatchdog.java:181)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: Both method-a and method-b set the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process, but they both set it to the same values (ExecuteWatchdog.watch = false and ExecuteWatchdog.process = null). method-b calls Watchdog.stop() on ExecuteWatchdog.watchdog, so it seems like method-a would be redundant in the case that method-b was called. CONNECTION_DOES_NOT_NECESSITATE_ORDERING",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-01-13",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 71,
        "inspection-start-time": "2022-02-06-01-13",
        "project": "commons-exec",
        "spec-id": "00203",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.destroyProcess()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00203.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:518",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:518)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-b checks whether the field value ExecuteWatchdog.caught is null, and throws it if it is not null. In its computations, method-a sets ExecuteWatchdog.caught, so it seems not useful to call method-b before method-a in the first place (at least, method-b should be called after the process has exited). I believe this is a case of CONNECTION_DOES_NOT_NECESSITATE_ORDERING, given that method-a and method-b are public methods that can be called at any point. Moreover, method-a may not necessarily always be called (method-a is only called when the user wants to kill the subprocess); for example, the subprocess may run to completion before the user has to call method-a to kill it. Note the SUPPLEMENTARY_EVIDENCE_BY_JAVADOC - the JavaDOC of method-b says that the exception thrown by method-b only remains valid once the process has been terminated either by error, timeout or manual intervention.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-01-26",
        "inspection-time-in-minutes": 13
    },
    {
        "iid": 72,
        "inspection-start-time": "2022-02-06-01-55",
        "project": "commons-exec",
        "spec-id": "00210",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00210.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:152",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:152)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a checks the field values ExecuteWatchdog.processStarted and ExecuteWatchdog.caught to ensure that either the process that the watchdog is monitoring started, or it has already terminated with an exception. method-b checks whether ExecuteWatchdog.caught is null, and throws it if it is not null. Since method-a and method-b only access ExecuteWatchdog.caught (neither of them modify the field variable), I think there is no temporal ordering between the two methods. CONNECTION_DOES_NOT_NECESSITATE_ORDERING",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-02-02",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 73,
        "inspection-start-time": "2022-02-06-02-04",
        "project": "commons-exec",
        "spec-id": "00211",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00211.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:152",
                        "method-b-site": "ExecuteWatchdog.java:181",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "UNRELATED_STATEFUL_METHODS: method-a checks the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught. method-b set the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process. Since these field variables are not directly related to each other, I believe this is a spruious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-02-07",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 74,
        "inspection-start-time": "2022-02-06-02-07",
        "project": "commons-exec",
        "spec-id": "00212",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00212.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:152",
                        "method-b-site": "DefaultExecutorTest.java:519",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "method-a checks the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught, and method-b is a 1-line naive getter to the field variable ExecuteWatchdog.killedProcess (ONE_STATELESS_METHOD). Since these field variables are not directly related to each other, I believe this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-02-11",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 75,
        "inspection-start-time": "2022-02-06-02-12",
        "project": "commons-exec",
        "spec-id": "00213",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00213.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:152",
                        "method-b-site": "ExecuteWatchdog.java:153",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "UNRELATED_STATEFUL_METHODS: method-a checks the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught. method-b set the field variables ExecuteWatchdog.watch, ExecuteWatchdog.process, and ExecuteWatchdog.killedProcess. Since these field variables are not directly related to each other, I believe this is a spruious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-02-15",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 76,
        "inspection-start-time": "2022-02-06-02-19",
        "project": "commons-exec",
        "spec-id": "00226",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "boolean",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00226.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:519",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:519)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + ONE_STATELESS_METHOD: method-a is a 1-line naive getter for the field variable ExecuteWatchdog.killedProcess, and method-b checks the field variable ExecuteWatchdog.caught, and throws it if it is not null. Since these two field variables are not directly related, this spec is spurious.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-02-24",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 77,
        "inspection-start-time": "2022-02-06-02-34",
        "project": "commons-exec",
        "spec-id": "00233",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 4,
        "code-snippets-file": "snippets/ls/00233.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:202)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a sets the field variable ExecuteWatchdog.processStarted to false, and method-b checks the field variable ExecuteWatchdog.caught, and throws it if it is not null. Since these two field variables are not directly related, this spec is spurious.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-02-44",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 78,
        "inspection-start-time": "2022-02-06-12-03",
        "project": "commons-exec",
        "spec-id": "00234",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00234.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "ExecuteWatchdog.java:181",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false, and method-b modifies the field variables ExecuteWatchdog.watch (to false) and ExecuteWatchdog.process (to null). Since these two field variables are not directly related, this spec is spurious.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-12-11",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 79,
        "inspection-start-time": "2022-02-06-12-11",
        "project": "commons-exec",
        "spec-id": "00235",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.destroyProcess()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00235.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "DefaultExecutorTest.java:518",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false, and method-b's callee (ExecuteWatchdog.ensureStarted()) has a conditional while loop with !ExecuteWatchdog.processStarted in an && expression. So, it seems like method-b *could* potentially end up in an infinite while loop (another way to leave the while loop is if ExecuteWatchdog.caught is not null, but it seems wrong for a process to have thrown an exception if it was not started), if ExecuteWatchdog.processStarted was not set to true between the computation of method-a and method-b. So, I think if anything there should be another method between these two methods for this to be called a potential true spec?",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-12-18",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 80,
        "inspection-start-time": "2022-02-06-12-18",
        "project": "commons-exec",
        "spec-id": "00236",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00236.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "ExecuteWatchdog.java:152",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false, and method-b has a conditional while loop with !ExecuteWatchdog.processStarted in an && expression. So, it seems like method-b *could* potentially end up in an infinite while loop (another way to leave the while loop is if ExecuteWatchdog.caught is not null, but it seems wrong for a process to have thrown an exception if it was not started), if ExecuteWatchdog.processStarted was not set to true between the computation of method-a and method-b. So, I think if anything there should be another method between these two methods for this to be called a potential true spec?",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-12-20",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 81,
        "inspection-start-time": "2022-02-06-12-20",
        "project": "commons-exec",
        "spec-id": "00238",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.isWatching()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00238.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "Exec34Test.java:88",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false, and method-b's callee (ExecuteWatchdog.ensureStarted()) has a conditional while loop with !ExecuteWatchdog.processStarted in an && expression. So, it seems like method-b *could* potentially end up in an infinite while loop (another way to leave the while loop is if ExecuteWatchdog.caught is not null, but it seems wrong for a process to have thrown an exception if it was not started), if ExecuteWatchdog.processStarted was not set to true between the computation of method-a and method-b. So, I think if anything there should be another method between these two methods for this to even be considered as a potential true spec?",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-12-30",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 82,
        "inspection-start-time": "2022-02-06-12-30",
        "project": "commons-exec",
        "spec-id": "00239",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00239.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "DefaultExecutorTest.java:519",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER + ONE_STATELESS_METHOD: method-b is a 1-line naive getter for the field variable ExecuteWatchdog.killedProcess, and method-a sets the field variable ExecuteWatchdog.processStarted to false.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-12-34",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 83,
        "inspection-start-time": "2022-02-06-12-34",
        "project": "commons-exec",
        "spec-id": "00240",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00240.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "DefaultExecutor.java:383",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:202)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "postcondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false (indicating that the subject process has not started), and method-b sets the field variable ExecuteWatchdog.processStarted to true (among other computations that it does). For a specific ExecuteWatchdog object (unless one wants to use the watchdog to monitor multiple processes sequentially...), I think that calling method-a after method-b would be dangerous (and would potentially end up in an infinite loop when ExecuteWatchdog.ensureStarted() is called), so I think this counts as a true spec.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-12-43",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 84,
        "inspection-start-time": "2022-02-06-12-50",
        "project": "commons-exec",
        "spec-id": "00241",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00241.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "DefaultExecutor.java:402",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:202)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:402)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted (indicating whether the subject process is verified as started), and method-b checks the field variable ExecuteWatchdog.hasWatchdog (and calls Watchdog.stop() if so), and modifies the field variables ExecuteWatchdog.watch and ExecuteWatchdog.process. I think the connection is moreso between ExecuteWatchdog.processStarted() and ExecuteWatchdog.start(), and between ExecuteWatchdog.start() and ExecuteWatchdog.stop() rather than between these two methods?",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-06-12-59",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 85,
        "inspection-start-time": "2022-02-06-12-59",
        "project": "commons-exec",
        "spec-id": "00242",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00242.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "ExecuteWatchdog.java:153",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false. method-b either checks that the process has already finished, or kills the process (since the watchdog has reached its timeout). Since method-b doesn't access/modify/affect the field variable that method-a sets, so I think it's safe to call this a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-13-07",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 86,
        "inspection-start-time": "2022-02-06-13-07",
        "project": "commons-exec",
        "spec-id": "00243",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.setProcessNotStarted()V",
        "method-b": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00243.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:202",
                        "method-b-site": "Watchdog.java:56",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:202)\nb @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + ONE_PURE_SETTER: method-a sets the field variable ExecuteWatchdog.processStarted to false. method-b doesn't access/modify/affect that field variable, so I think it's safe to call this a spurious spec. Note that if the Watchdog object was never started, then method-b would never be called.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-13-23",
        "inspection-time-in-minutes": 16
    },
    {
        "iid": 87,
        "inspection-start-time": "2022-02-06-13-54",
        "project": "commons-exec",
        "spec-id": "00245",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.cleanUp()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 8,
        "code-snippets-file": "snippets/ls/00245.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "ExecuteWatchdog.java:181",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:181)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }

        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "postcondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-b sets a kind of postcondition for method-a, since method-a sets ExecuteWatchdog.process to the argument processToMonitor, and method-b sets it back to null. This seems like kind of a \"ab?\" kind of relationship? Potentially MORE_COMPLEX_THAN_AB. Note that if the DSI experiment was actually able to run, the subprocess will run forever (as it consists of an infinite loop) because method-a sets the handle on the subprocess, and the caller of method-b would only be able to kill the program if it has that handle.",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-14-05",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 88,
        "inspection-start-time": "2022-02-06-14-05",
        "project": "commons-exec",
        "spec-id": "00246",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.destroyProcess()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00246.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "DefaultExecutorTest.java:518",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:518)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }

        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets up the watchdog, including the link between the subprocess and the watchdog, and method-b destroys the subprocess using the handle (and also cleans up). Note that if the DSI experiment was actually conducted, the subprocess will run forever (as it consists of an infinite loop) because method-a sets the handle on the subprocess, and method-b would only be able to kill the program if has that handle. This seems like a SOMETIMES_TRUE_SPEC for situations where the user wants to manually destroy the process using method-b.",
        "findings": "One can write a JavaMOP spec as: \"[](method-b ==> (*) method-a).\"",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-14-10",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 89,
        "inspection-start-time": "2022-02-06-14-10",
        "project": "commons-exec",
        "spec-id": "00247",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00247.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "ExecuteWatchdog.java:152",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:518)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG + SUPPLEMENTARY_EVIDENCE_BY_JAVADOC: method-a sets the field variable ExecuteWatchdog.caught to null, and ExecuteWatchdog.processStarted to true. method-b loops until either ExecuteWatchdog.processStarted is true, or ExecuteWatchdog.caught is not null. Since calling method-a satisfies one of these conditions, and from the Javadoc comments it seems like method-b is a check on whether method-a was called, I think this ought to be counted as a true spec.",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-14-16",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 90,
        "inspection-start-time": "2022-02-06-14-16",
        "project": "commons-exec",
        "spec-id": "00248",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.isWatching()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00248.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "Exec34Test.java:88",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:88)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variables ExecuteWatchdog.caught to null, and ExecuteWatchdog.processStarted to true. The callee of method-b loops until either ExecuteWatchdog.processStarted is true, or ExecuteWatchdog.caught is not null. DECISION: since method-b is a public method that can be called at any point, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-14-22",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 91,
        "inspection-start-time": "2022-02-06-14-22",
        "project": "commons-exec",
        "spec-id": "00249",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00249.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "DefaultExecutorTest.java:519",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:519)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: In starting the watchdog of the new process, method-a sets the field variable ExecuteWatchdog.killedProcess (signifying whether the most recent process checked by the watchdog was killed or not). ONE_STATELESS_METHOD: method-b is a 1-line naive getter for this field variable. I don't know whether there is a strict temporal relationship between these two methods, because the operation done by method-b is a part of cleaning out the state of the previous run. DECISION: method-b is public and can be called at any time that one chooses",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-14-26",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 92,
        "inspection-start-time": "2022-02-06-14-38",
        "project": "commons-exec",
        "spec-id": "00251",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00251.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "ExecuteWatchdog.java:153",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:153)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:383)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }

        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets up the watchdog, including the link between the subprocess and the watchdog, and method-b destroys the subprocess using the handle (and also cleans up). Note that if the DSI experiment was actually conducted, the subprocess will run forever (as it consists of an infinite loop) because method-a sets the handle on the subprocess, and method-b would only be able to kill the program if has that handle. This is a CONNECTION_DOES_NOT_NECESSITATE_ORDERING case, because method-a and method-b are public methods, and method-b executes and exits cleanly even if method-a was not called.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-14-41",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 93,
        "inspection-start-time": "2022-02-06-14-41",
        "project": "commons-exec",
        "spec-id": "00252",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00252.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "Watchdog.java:56",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutor.java:383)\nb @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a sets the field variable ExecuteWatchdog.process to the argument processToMonitor, effectively creating the link between the watchdog and the subprocess it needs to monitor. Since method-b is called to check whether the subprocess has exited by that point, and destroy the subprocess via ExecuteWatchdog.process.destroy() if it has not, method-a *needs* to be called before method-b in order for method-b to execute successfully (and potentially prevent a nonterminating subprocess from running forever). Also, method-b itself would not be executed if method-a was not called, because the caller of method-b would only be called if the watchdog was run via Watchdog.start() (called from method-a - SPECIAL_NBP). DYNAMIC_DISPATCH",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-14-47",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 94,
        "inspection-start-time": "2022-02-06-14-48",
        "project": "commons-exec",
        "spec-id": "00253",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00253.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:402",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
        "notes": "method-b checks for the field variable ExecuteWatchdog.caught, and throws it if it is not null. method-a stops the watchdog from monitoring the process, and doesn't access/modify/impact that field variable.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-14-56",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 95,
        "inspection-start-time": "2022-02-06-14-56",
        "project": "commons-exec",
        "spec-id": "00254",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00254.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:402",
                        "method-b-site": "ExecuteWatchdog.java:209",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:209)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:402)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-b checks for the field variables ExecuteWatchdog.processStarted and ExecuteWatchdog.caught, but neither of them is accessed/modified/affected by method-a. method-a stops the watchdog from monitoring the process. Hence, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-15-07",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 96,
        "inspection-start-time": "2022-02-06-15-07",
        "project": "commons-exec",
        "spec-id": "00255",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.isWatching()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00255.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:402",
                        "method-b-site": "Exec34Test.java:88",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:88)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:402)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-b checks for the field variables ExecuteWatchdog.processStarted, ExecuteWatchdog.caught, and the returns the field variable ExecuteWatchdog.watch. method-a sets ExecuteWatchdog.watch to false. I can see two use cases for these two methods: (1) method-b is called before method-a to check whether the watchdog is still monitoring a process that it shouldn't be, and hence it calls method-a afterwards to make the watchdog stop monitoring the process; (2) method-b is called after method-a to ensure that after method-a is called, the watchdog is no longer monitoring the process (this is the use case of the test). So, this seems like a \"b*ab*\" kind of spec instead? MORE_COMPLEX_THAN_AB.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-15-12",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 97,
        "inspection-start-time": "2022-02-06-15-12",
        "project": "commons-exec",
        "spec-id": "00256",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00256.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:402",
                        "method-b-site": "Exec34Test.java:87",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:87)\na @ Thd[27]Obj[0]:0(DefaultExecutor.java:402)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG + ONE_STATELESS_METHOD - method-b is a 1-line naive getter for the field variable ExecuteWatchdog.killedProcess, and method-a doesn't access/modify/affect that field value. method-a stops the watchdog from monitoring the process.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-15-16",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 98,
        "inspection-start-time": "2022-02-06-15-16",
        "project": "commons-exec",
        "spec-id": "00257",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00257.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:153",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:153)\nb @ Thd[31]Obj[0]:0(DefaultExecutor.java:420)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a handles the watchdog after the specified timeout was reached, and method-b checks for the field variable ExecuteWatchdog.caught, and throws it if it is not null. In its computation, method-a *can* set the field variable ExecuteWatchdog.caught (if an exception was thrown), but it may not if the handling executes without an exception being thrown. Either way, it doesn't make sense to call method-b before method-a. There's also the case that one can call method-b without having called method-a at all (if the process exited normally before the timeout threshold was reached). SUPPLEMENTARY_EVIDENCE_BY_JAVADOC - Documented in Javadoc that method-b only remains valid once the process has been terminated either by error, timeout, or manual intervention. DECISION: I think this should be ruled as a spurious-spec, given that method-b is a public method that can be called at any point. This is more like a CONNECTION_DOES_NOT_NECESSITATE_ORDERING, since calling method-a also doesn't necessitate calling method-b.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-15-27",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 99,
        "inspection-start-time": "2022-02-06-19-48",
        "project": "commons-exec",
        "spec-id": "00276",
        "method-a": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00276.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:507",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:507)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:412)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a essentially creates a Runnable thread that calls method-b, and runs that thread. So, this is a special kind of NBP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-19-56",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 100,
        "inspection-start-time": "2022-02-06-20-05",
        "project": "commons-exec",
        "spec-id": "00278",
        "method-a": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 11,
        "code-snippets-file": "snippets/ls/00278.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:507",
                        "method-b-site": "DefaultExecutor.java:47",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:507)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:47)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a essentially creates a Runnable thread that calls method-b, and runs that thread. So, this is a special kind of NBP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-20-08",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 101,
        "inspection-start-time": "2022-02-06-20-19",
        "project": "commons-exec",
        "spec-id": "00280",
        "method-a": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00280.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:507",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:507)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:414)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP : method-a essentially creates a Runnable thread that calls method-b, and runs that thread. So, this is a special kind of NBP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-20-24",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 102,
        "inspection-start-time": "2022-02-06-20-28",
        "project": "commons-exec",
        "spec-id": "00283",
        "method-a": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 9,
        "code-snippets-file": "snippets/ls/00283.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:507",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:507)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:431)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a essentially creates a Runnable thread that calls method-b, and runs that thread. So, this is a special kind of NBP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-20-30",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 103,
        "inspection-start-time": "2022-02-06-20-30",
        "project": "commons-exec",
        "spec-id": "00284",
        "method-a": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 11,
        "code-snippets-file": "snippets/ls/00284.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:507",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:507)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:351)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + SPECIAL_NBP: method-a essentially creates a Runnable thread that calls method-b, and runs that thread. So, this is a special kind of NBP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-20-32",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 104,
        "inspection-start-time": "2022-02-06-20-39",
        "project": "commons-exec",
        "spec-id": "00286",
        "method-a": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-b": "org.apache.commons.exec.Executor.getWorkingDirectory()Ljava/io/File;",
        "method-a-return-type": "boolean",
        "method-b-return-type": "java.io.File",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00286.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:106",
                        "method-b-site": "DefaultExecutorTest.java:107",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_EXPECTED_OUTPUT: method-a is expected to return false (and checked by an assertFalse()), and DSI replaces the return value of method-a with the default value false.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "ONE_STATELESS_METHOD: the only implementation of method-b is a 1-line naive getter to the field variable DefaultExecutor.workingDirectory, and method-a doesn't access/modify/affect that field variable (The only implementation of method-a checks whether the argument exitValue signals that the process failed, using the field variable DefaultExecutor.exitValues).",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-20-46",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 105,
        "inspection-start-time": "2022-02-06-20-46",
        "project": "commons-exec",
        "spec-id": "00287",
        "method-a": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00287.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:440",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: the critical point at which method-a needs to be called by is DefaultExecutor.java:431. Since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "The only implementation of method-a modifies the field variable DefaultExecutor.exitValues (the list of exit values signalling a valid run) to include the argument int value (it is not a pure setter). method-b does not access/modify/affect that field variable (method-b closes the input/output/error streams of the finished process), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-20-55",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 106,
        "inspection-start-time": "2022-02-06-21-10",
        "project": "commons-exec",
        "spec-id": "00290",
        "method-a": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00290.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:440",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: the critical point at which method-a needs to be called by is DefaultExecutor.java:431. Since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "The only implementation of method-a modifies the field variable DefaultExecutor.exitValues (the list of exit values signalling a valid run) to include the argument int value (it is not a pure setter). ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.exceptionCaught. Since method-a does not access/modify/affect this field variable, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-21-17",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 107,
        "inspection-start-time": "2022-02-06-21-33",
        "project": "commons-exec",
        "spec-id": "00292",
        "method-a": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00292.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:440",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: the critical point at which method-a needs to be called by is DefaultExecutor.java:431. Since method-b is called before that point, the delayed call to method-a was able to restore the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "The only implementation of method-a modifies the field variable DefaultExecutor.exitValues (the list of exit values signalling a valid run) to include the argument int value. method-b does not access/modify/affect that field variable (method-b creates a process to run the command), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-21-36",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 108,
        "inspection-start-time": "2022-02-06-21-48",
        "project": "commons-exec",
        "spec-id": "00295",
        "method-a": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-b": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00295.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:454",
                        "method-b-site": "DefaultExecutorTest.java:459",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION - it seems like this test expects the exception that the implementation of method-b is a guard against, and calling method-a here is a kind of a no-op as the call to method-a sets the value 0 to be a valid exit code, even though 0 is the canonical valid exit code. The actual exit code of the process is 1."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "Removing the call to method-a in DSIValidationTest#testDSI00295 will make the test fail, but that is simply because of the optional connection between method-a and method-b",
        "notes": "DYNAMIC_DISPATCH (both methods are from an interface class). The only implementation of method-a modifies the field variable DefaultExecutor.exitValues (the list of exit values signalling a valid run) to include the argument int value. The only implementation of method-b uses the field variable DefaultExecutor.exitValues to determine whether the exit value of the process implies that the process failed. This is most likely a CONNECTION_DOES_NOT_NECESSITATE_ORDERING case given that calling method-a is optional (and it's unlikely that a normal user would want to set an exit value other than 0 to valid), and the client themselves does not need to call method-b unless they wanted to check that the exit value that the process ended on was a failure, and the client themselves can only get a handle on the exit value if it was indeed deemed as a failure exit code. Even if it was a sometimes true spec, this spec will not be useful for JavaMOP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-21-53",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 109,
        "inspection-start-time": "2022-02-06-21-53",
        "project": "commons-exec",
        "spec-id": "00296",
        "method-a": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-b": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00296.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:101",
                        "method-b-site": "TutorialTest.java:106",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample",
        "notes": "The only implementation of method-a and the only implementation of method-b are both setters (ONE_PURE_SETTER: method-a is not a pure setter).",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-21-59",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 110,
        "inspection-start-time": "2022-02-06-21-59",
        "project": "commons-exec",
        "spec-id": "00297",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00297.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b does not access/modify/affect that field variable (it closes the streams for the argument Process), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-22-04",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 111,
        "inspection-start-time": "2022-02-06-22-04",
        "project": "commons-exec",
        "spec-id": "00298",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Thread",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00298.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:506",
                        "method-b-site": "DefaultExecutor.java:222",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b does not access/modify/affect that field variable (it simply creates a new Thread object and returns it), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-22-11",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 112,
        "inspection-start-time": "2022-02-06-23-12",
        "project": "commons-exec",
        "spec-id": "00299",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00299.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the process would terminate before it needed to get destroyed, and method-b does a clean up at the end such that the assertions at the end of the test still hold even though method-a was called after method-b."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b uses the field variable DefaultExecutor.processDestroyer in the case that it is set in order to connect the ProcessDestroyer object and the running process. So, this looks like a SOMETIMES_TRUE_SPEC in the case that the user wanted to set a ProcessDestroyer object in order to apply some computation to the process when the VM is destroyed.",
        "findings": "One can encode the following spec in JavaMOP: If a ProcessDestroyer object is declared, then a call to method-b should be preceded by method-a.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-23-23",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 113,
        "inspection-start-time": "2022-02-06-23-23",
        "project": "commons-exec",
        "spec-id": "00300",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00300.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the process would terminate before it needed to get destroyed, and method-b does a clean up at the end such that the assertions at the end of the test are still met even though method-a was called after method-b."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "INSPECTION_TODO? although, I'm not sure how one would check for this",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b uses the field variable DefaultExecutor.processDestroyer in the case that it is set in order to connect the ProcessDestroyer object and the running process. So, this looks like a SOMETIMES_TRUE_SPEC in the case that the user wanted to set a ProcessDestroyer object in order to apply some computation to the process when the VM is destroyed.",
        "findings": "One can encode the following spec in JavaMOP: If a ProcessDestroyer object is declared, then a call to method-b should be preceded by method-a.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-23-28",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 114,
        "inspection-start-time": "2022-02-06-23-28",
        "project": "commons-exec",
        "spec-id": "00301",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00301.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:506",
                        "method-b-site": "DefaultExecutor.java:186",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the call to DefaultExecutor.executeInternal() is in an asynchronous thread, rather than within method-b? So, when the delayed call to method-a happened, maybe it was called before DefaultExecutor.executeInternal() got to the point where it hooked the subprocess to DefaultExecutor.processDestroyer. Anyways, this is a super interesting case, because the test does check for the state of DefaultExecutor.processDestroyer while the process is running, and after it has run (CONCURRENCY + GOOD_EXAMPLE)."
            }
        ],
        "verdict": "sometimes-true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "INSPECTION_TODO",
        "notes": "The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b spawns a new thread that runs DefaultExecutor.executeInternal(), which checks and uses the field variable DefaultExecutor.processDestroyer to connect the ProcessDestroyer object to the running process. It seems like good practice to call method-a before method-b in the cases that one would want to use a process destroyer (SOMETIMES_TRUE_SPEC) but it seems like the DSI experiment got away with its manipulations even though the test checks for the state of the process destroyer during the execution of the subprocess, so I'm a bit unsure here.",
        "findings": "Potentially interesting case about how DSI's delay manipulations deal with asynchronicity!! One can resolve the SOMETIMES_TRUE_SPEC by making the JavaMOP spec (ab|b), since calling method-a after method-b will not trigger the intended effects/be incorrect, but one can still call method-b without first calling method-a. MORE_COMPLEX_THAN_AB",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-06-23-42",
        "inspection-time-in-minutes": 14
    },
    {
        "iid": 115,
        "inspection-start-time": "2022-02-06-23-42",
        "project": "commons-exec",
        "spec-id": "00302",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00302.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER + ONE_STATELESS_METHOD: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b does not access/modify/affect that field variable (ONE_STATELESS_METHOD: method-b is a 1-line naive getter for the field variable DefaultExecutor.exceptionCaught), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-23-44",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 116,
        "inspection-start-time": "2022-02-06-23-44",
        "project": "commons-exec",
        "spec-id": "00303",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Thread",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00303.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:506",
                        "method-b-site": "DefaultExecutor.java:223",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b does not access/modify/affect that field variable (ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.executorThread), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-23-48",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 117,
        "inspection-start-time": "2022-02-06-23-48",
        "project": "commons-exec",
        "spec-id": "00304",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00304.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b does not access/modify/affect that field variable (method-b checks whether the argument exitValue indicated whether the process failed or not, using the field variable DefaultExecutor.exitValues), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-23-53",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 118,
        "inspection-start-time": "2022-02-06-23-53",
        "project": "commons-exec",
        "spec-id": "00305",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00305.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b does not access/modify/affect that field variable (method-b creates and starts a new process, and returns it), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-23-55",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 119,
        "inspection-start-time": "2022-02-06-23-55",
        "project": "commons-exec",
        "spec-id": "00306",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00306.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutorTest.java:478",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the process would terminate before it needed to get destroyed, and method-b does a clean up at the end such that the assertions at the end of the test are still met even though method-a was called after method-b."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "INSPECTION_TODO",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. The only implementation of method-b uses the field variable DefaultExecutor.processDestroyer, if it is set, to connect the ProcessDestroyer object to the subject process so that it can execute when the VM is destroyed. So, this looks like a SOMETIMES_TRUE_SPEC in the case that the user wanted to set and use a ProcessDestroyer object?",
        "findings": "One can encode the following spec in JavaMOP: If a ProcessDestroyer object is declared, then a call to method-b should be preceded by method-a.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-00-00",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 120,
        "inspection-start-time": "2022-02-07-00-00",
        "project": "commons-exec",
        "spec-id": "00307",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00307.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:506",
                        "method-b-site": "DefaultExecutorTest.java:507",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the call to DefaultExecutor.executeInternal() is in an asynchronous thread, rather than within method-b? So, when the delayed call to method-a happened, maybe it was called before DefaultExecutor.executeInternal() got to the point where it hooked the subprocess to DefaultExecutor.processDestroyer. Anyways, this is a super interesting case, because the test does check for the state of DefaultExecutor.processDestroyer while the process is running, and after it has run (CONCURRENCY + GOOD_EXAMPLE)."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "INSPECTION_TODO",
        "notes": "The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. method-b spawns a new thread that runs DefaultExecutor.executeInternal(), which checks and uses the field variable DefaultExecutor.processDestroyer to connect it with the running process so it can execute if/when the VM is destroyed. It seems like good practice to call method-a before method-b in the cases that one would want to use a process destroyer (SOMETIMES_TRUE_SPEC?) ",
        "findings": "One can encode the following spec in JavaMOP: If a ProcessDestroyer object is declared, then a call to method-b should be preceded by method-a.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-00-03",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 121,
        "inspection-start-time": "2022-02-07-00-03",
        "project": "commons-exec",
        "spec-id": "00308",
        "method-a": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-b": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00308.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:473",
                        "method-b-site": "DefaultExecutorTest.java:481",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.processDestroyer. The only implementation of method-b does not access/modify/affect that field variable (it checks whether the argument exitValue indicated whether the process failed or not, using the field variable DefaultExecutor.exitValues), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-00-10",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 122,
        "inspection-start-time": "2022-02-07-00-39",
        "project": "commons-exec",
        "spec-id": "00310",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Thread",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00310.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:222",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: method-a needs to be called before DefaultExecutor.java:223 (the call to Thread.start()), because that's when DefaultExecutor.streamHandler gets passed into DefaultExecutor.executeInternal() as a final argument. Since method-b is called before that point, the delayed call to method-a succesfully restored the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.streamHandler. method-b does not access/modify/affect that field variable (it creates a new Thread object and returns it), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-00-46",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 123,
        "inspection-start-time": "2022-02-07-01-38",
        "project": "commons-exec",
        "spec-id": "00313",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00313.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:186",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "INSPECTION_TODO - just need a test that calls method-a and also checks for the output stream after execution?",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler. method-b passes into DefaultExecutor.executeInternal() as a final argument streams DefaultExecutor.streamHandler, and uses streams to connect the intended input/output/error streams between the parent and child processes. Hence, one *needs* to call method-a before method-b if it wanted to set a different ExecuteStreamHandler object rather than the preset one (new PumpStreamHandler(), which redirects the subprocess output to StdOut). DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-01-45",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 124,
        "inspection-start-time": "2022-02-07-02-00",
        "project": "commons-exec",
        "spec-id": "00315",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Thread",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00315.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:223",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: method-a needs to be called before DefaultExecutor.java:223 (the call to Thread.start()), because that's when DefaultExecutor.streamHandler gets passed into DefaultExecutor.executeInternal() as a final argument. Since method-b is called before that point, the delayed call to method-a succesfully restored the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.streamHandler. ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.executorThread, which is not related to DefaultExecutor.streamHandler, so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-02-04",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 125,
        "inspection-start-time": "2022-02-07-12-07",
        "project": "commons-exec",
        "spec-id": "00318",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00318.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:229",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec (wrt method-a), given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "UNRELATED_PURE_SETTERS: The only implementation of method-a and method-b are both 1-line setters (not sure whether method-b is a pure setter because it contains some computation done in the form of an expression) for different field variables that are not related, so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-12-12",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 126,
        "inspection-start-time": "2022-02-07-12-36",
        "project": "commons-exec",
        "spec-id": "00321",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00321.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:507",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "INSPECTION_TODO",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter for the field variable DefaultExecutor.streamHandler. The only implementation of method-b passes into DefaultExecutor.executeInternal() as a final argument streams DefaultExecutor.streamHandler, and uses streams to connect the intended input/output/error streams between the parent and child processes. Hence, one *needs* to call method-a before method-b if it wanted to set a different ExecuteStreamHandler object rather than the preset one (new PumpStreamHandler(), which redirects the subprocess output to StdOut). DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-12-39",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 127,
        "inspection-start-time": "2022-02-07-13-05",
        "project": "commons-exec",
        "spec-id": "00324",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00324.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:440",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec (wrt method-a), given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter for the field variable DefaultExecutor.streamHandler, and the only implementation of method-b is a setter (more complicated than a pure setter) for the field variable DefaultExecutor.exitValues. Since these field variables are not related, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-13-09",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 128,
        "inspection-start-time": "2022-02-07-13-09",
        "project": "commons-exec",
        "spec-id": "00325",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00325.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:473",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec (wrt method-a), given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
        "notes": "The only implementation of method-a is a non-pure setter for the field variable DefaultExecutor.exitValues, and the only implementation of method-b is a pure setter to the field variable DefaultExecutor.watchdog (ONE_PURE_SETTER). Since these two variables are not directly related, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-13-11",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 129,
        "inspection-start-time": "2022-02-07-13-11",
        "project": "commons-exec",
        "spec-id": "00326",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 3,
        "code-snippets-file": "snippets/ls/00326.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:505",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec (wrt method-a), given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "The only implementations of method-a and method-b are UNRELATED_PURE_SETTERS - the implementation of method-a sets the field variable DefaultExecutor.streamHandler, and the implementation of method-b sets the field variable DefaultExecutor.watchdog.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-13-15",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 130,
        "inspection-start-time": "2022-02-07-13-20",
        "project": "commons-exec",
        "spec-id": "00327",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00327.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:114",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
        "notes": "The only implementations of method-a and method-b are UNRELATED_PURE_SETTERS - the implementation of method-a sets the field variable DefaultExecutor.streamHandler, and the implementation of method-b sets the field variable DefaultExecutor.workingDirectory",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-13-23",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 131,
        "inspection-start-time": "2022-02-07-13-28",
        "project": "commons-exec",
        "spec-id": "00328",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00328.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:505)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:412)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. method-b does not access/modify/affect that field variable (it closes the streams for the argument Process object), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-13-38",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 132,
        "inspection-start-time": "2022-02-07-13-40",
        "project": "commons-exec",
        "spec-id": "00329",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.createThread(Ljava/lang/Runnable;Ljava/lang/String;)Ljava/lang/Thread;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Thread",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00329.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutor.java:222",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "method-a actually needs to be called before DefaultExecutor.java:201, because that's when DefaultExecutor.watchDog is used for the first time. However, this use is simply to call ExecuteWatchdog.setProcessNotStarted(), which is a no-op in this test's case because the constructor of ExecuteWatchdog() achieves the same effect (sets ExecuteWatchdog.processStarted to false). STATE_RESTORED: the first use of DefaultExecutor.watchDog that is not a no-op in this test is within DefaultExecutor.executeInternal(), which is called when the thread created via method-b is started. Since method-b doesn't actually start the thread, the state is restored via the delayed call to method-a after method-b."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. method-b does not access/modify/affect that field variable (it creates a new Thread object and returns it), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-13-49",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 133,
        "inspection-start-time": "2022-02-07-13-38",
        "project": "commons-exec",
        "spec-id": "00330",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00330.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutor.java:47",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:505)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:47)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog (method-a is the only place in the code that sets DefaultExecutor.watchDog). method-b uses the field variable DefaultExecutor.watchDog in order to set up the connection between the watchdog and the running subprocess, so that the watchdog can kill the process if it runs for too long. Hence, this is a SOMETIMES_TRUE_SPEC in the cases where the user wants to set a timeout via using the watchdog.",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-13-53",
        "inspection-time-in-minutes": 15
    },
    {
        "iid": 134,
        "inspection-start-time": "2022-02-07-14-03",
        "project": "commons-exec",
        "spec-id": "00331",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00331.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:106",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is weak for checking the effects of calling method-a because the timeout at which the watchdog is supposed to come and kill the process is *much* longer than how long the process would take to normally finish; hence, the watchdog isn't really used."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample with the block TutorialTest.java:104-107 moved pased the block ending at TutorialTest.java:119, with the value set at TutorialTest.java:50 to be 900 (or less).",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. The callee of method-b (DefaultExecutor.executeInternal()) uses the field variable DefaultExecutor.watchDog in order to set up the connection between the watchdog and the running subprocess, so that the watchdog can kill the process if it runs for too long. Hence, this is a SOMETIMES_TRUE_SPEC in the cases where the user wants to institute a timeout using the watchdog.",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-14-10",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 135,
        "inspection-start-time": "2022-02-07-14-10",
        "project": "commons-exec",
        "spec-id": "00332",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00332.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutor.java:186",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the call to DefaultExecutor.executeInternal() is in an asynchronous thread, rather than within method-b? So, when the delayed call to method-a happened, maybe it was called before DefaultExecutor.executeInternal() got to the point where it hooked the subprocess to DefaultExecutor.watchDog. The fact that the test checks that the watchdog killed the process (and that same test passed) indicates that DefaultExecutor.executeInternal() was able to get a handle on the watchdog and get it to monitor the subprocess."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample with the block TutorialTest.java:104-107 moved pased the block ending at TutorialTest.java:119, with the value set at TutorialTest.java:50 to be 900 (or less).",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. method-b spawns a new thread that runs DefaultExecutor.executeInternal(), which checks and uses the field variable DefaultExecutor.watchDog in order to set up the connection between the watchdog and the running subprocess, so that the watchdog can kill the process if it runs for too long. Hence, this is a SOMETIMES_TRUE_SPEC in the cases where the user wants to institute a timeout using the watchdog.",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-14-22",
        "inspection-time-in-minutes": 12
    },
    {
        "iid": 136,
        "inspection-start-time": "2022-02-07-14-22",
        "project": "commons-exec",
        "spec-id": "00333",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00333.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:106",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is weak for checking the effects of calling method-a because the timeout at which the watchdog is supposed to come and kill the process is *much* longer than how long the process would take to normally finish; hence, the watchdog isn't really used."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.exceptionCaught. Because these two field variables are unrelated, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-14-27",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 137,
        "inspection-start-time": "2022-02-07-14-27",
        "project": "commons-exec",
        "spec-id": "00334",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExecutorThread()Ljava/lang/Thread;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Thread",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00334.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutor.java:223",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "method-a actually needs to be called before DefaultExecutor.java:201, because that's when DefaultExecutor.watchDog is used for the first time. However, this use is simply to call ExecuteWatchdog.setProcessNotStarted(), which is a no-op in this test's case because the constructor of ExecuteWatchdog() achieves the same effect (sets ExecuteWatchdog.processStarted to false). STATE_RESTORED: the first use of DefaultExecutor.watchDog that is not a no-op in this test is within DefaultExecutor.executeInternal(), which is called when the thread created via method-b is started. Since method-b doesn't actually start the thread, the state is restored via the delayed call to method-a after method-b."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.executorThread. Because these two field variables by themselves are unrelated, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-14-32",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 138,
        "inspection-start-time": "2022-02-07-14-32",
        "project": "commons-exec",
        "spec-id": "00336",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00336.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:106",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is weak for checking the effects of calling method-a because the timeout at which the watchdog is supposed to come and kill the process is *much* longer than how long the process would take to normally finish; hence, the watchdog isn't really used."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. method-b checks whether the argument exitValue signifies that the subprocess has failed by using the field variable DefaultExecutor.exitValues. Because these two field variables are unrelated, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-14-35",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 139,
        "inspection-start-time": "2022-02-07-14-35",
        "project": "commons-exec",
        "spec-id": "00337",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 7,
        "code-snippets-file": "snippets/ls/00337.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:106",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is weak for checking the effects of calling method-a because the timeout at which the watchdog is supposed to come and kill the process is *much* longer than how long the process would take to normally finish; hence, the watchdog isn't really used."
            }
        ],
        "verdict": "sometimes-true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. method-b creates and starts the subject subprocess to which the watchdog will be monitoring. The first use of DefaultExecutor.watchDog in this test is in the catch block of executing method-b (watchdog.failedToStart()), so it seems like this is a SOMETIMES_TRUE_SPEC in the case that the user wants to use a watchdog to institute a timeout on the subprocess? There is a chance that even if method-a is called after method-b, method-a will still be called before the critical point where DefaultExecutor.watchDog will be first used (because that point is executed in a concurrent thread that is started at the end of method-b).",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-14-49",
        "inspection-time-in-minutes": 14
    },
    {
        "iid": 140,
        "inspection-start-time": "2022-02-07-15-20",
        "project": "commons-exec",
        "spec-id": "00338",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00338.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.TutorialTest#testTutorialExample",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "TutorialTest.java:106",
                        "method-b-site": "TutorialTest.java:117",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is weak for checking the effects of calling method-a because the timeout at which the watchdog is supposed to come and kill the process is *much* longer than how long the process would take to normally finish; hence, the watchdog isn't really used."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample with the block TutorialTest.java:104-107 moved pased the block ending at TutorialTest.java:119, with the value set at TutorialTest.java:50 to be 900 (or less).",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. The indirect callee of the only implementation of method-b (DefaultExecutor.executeInternal()) uses the field variable DefaultExecutor.watchDog to set up the connection between the watchdog and the running subprocess, so that the watchdog can kill the process if it runs for too long. Hence, this is a SOMETIMES_TRUE_SPEC if the user wants to set up the watchdog to institute a timeout mechanism.",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-15-23",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 141,
        "inspection-start-time": "2022-02-07-15-23",
        "project": "commons-exec",
        "spec-id": "00339",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;Lorg/apache/commons/exec/ExecuteResultHandler;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "code-snippets-file": "snippets/ls/00339.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutorTest.java:507",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test most likely passed because the call to DefaultExecutor.executeInternal() is in an asynchronous thread, rather than within method-b? So, when the delayed call to method-a happened, maybe it was called before DefaultExecutor.executeInternal() got to the point where it hooked the subprocess to DefaultExecutor.watchDog. The fact that the test checks that the watchdog killed the process (and that same test passed) indicates that DefaultExecutor.executeInternal() was able to get a handle on the watchdog and get it to monitor the subprocess."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.TutorialTest#testTutorialExample with the block TutorialTest.java:104-107 moved pased the block ending at TutorialTest.java:119, with the value set at TutorialTest.java:50 to be 900 (or less).",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.watchDog. The indirect callee of the only implementation of method-b (DefaultExecutor.executeInternal()) uses the field variable DefaultExecutor.watchDog to set up the connection between the watchdog and the running subprocess, so that the watchdog can kill the process if it runs for too long. Hence, this is a SOMETIMES_TRUE_SPEC if the user wants to set up the watchdog to institute a timeout mechanism.",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-15-26",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 142,
        "inspection-start-time": "2022-02-07-15-26",
        "project": "commons-exec",
        "spec-id": "00340",
        "method-a": "org.apache.commons.exec.Executor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.Executor.setProcessDestroyer(Lorg/apache/commons/exec/ProcessDestroyer;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00340.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:505",
                        "method-b-site": "DefaultExecutorTest.java:506",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "STATE_RESTORED: method-a ought to be called before DefaultExecutorTest.java:507 (or the call to DefaultExecutor.executeInternal()), but since method-b is before that point, the delayed call to method-a restores the state."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "The only implementations of method-a and method-b are UNRELATED_PURE_SETTERS - the implementation of method-a sets the field variable DefaultExecutor.watchdog, and the implementation of method-b sets the field variable DefaultExecutor.processDestroyer.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-15-29",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 143,
        "inspection-start-time": "2022-02-07-15-29",
        "project": "commons-exec",
        "spec-id": "00341",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00341.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory/snippet",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. method-b does not access/modify/affect that field variable (it closes the input/output/error streams of its argument Process object), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-15-34",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 144,
        "inspection-start-time": "2022-02-07-15-34",
        "project": "commons-exec",
        "spec-id": "00342",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00342.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. DefaultExecutor.workingDirectory gets passed to method-b as the final File argument dir, and method-b uses this variable dir to set up the subprocess to run on that directory. So, it seems fair that method-a ought to be called before method-b if the user wanted to specify a different directory for the process to execute in. DECISION: Since the field variable DefaultExecutor.workingDirectory is set to a default value in the constructor of DefaultExecutor, and method-a is a public method that can be called at any point, this is more likely a spurious spec than a sometimes true spec (CONNECTION_DOES_NOT_NECESSITATE_ORDERING). A user can call method-a before method-b to change the directory in which the process that method-b would run, but the user does not have to as well. Even if we attempted to encode this in JavaMOP, I don't think we can automatically infer the situations in which method-a ought to be called, which means this will not be a helpful spec for JavaMOP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-15-42",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 145,
        "inspection-start-time": "2022-02-07-15-59",
        "project": "commons-exec",
        "spec-id": "00344",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00344.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory/snippet",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. method-b does not access/modify/affect that field variable (ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.exceptionCaught), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-16-03",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 146,
        "inspection-start-time": "2022-02-07-16-03",
        "project": "commons-exec",
        "spec-id": "00345",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00345.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory/snippet",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. method-b does not access/modify/affect that field variable (it checks whether the argument exitValue signifies that the subprocess has failed by using the field variable DefaultExecutor.exitValues), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-16-05",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 147,
        "inspection-start-time": "2022-02-07-16-05",
        "project": "commons-exec",
        "spec-id": "00346",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00346.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of an echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory/snippet",
        "notes": "The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. The caller of method-b (DefaultExecutor.executeInternal()) receives as a final argument File dir the field variable DefaultExecutor.workingDirectory, and passes it into method-b. (Note that there is only one use case of method-b in the entire project). method-b takes this argument and creates and starts a subprocess running the specified command in that directory. DECISION: Since the field variable DefaultExecutor.workingDirectory is set to a default value in the constructor of DefaultExecutor, and method-a is a public method that can be called at any point, this is more likely a spurious spec than a sometimes true spec (CONNECTION_DOES_NOT_NECESSITATE_ORDERING). A user can call method-a before method-b to change the directory in which the process that method-b would run, but the user does not have to as well. Even if we attempted to encode this in JavaMOP, I don't think we can automatically infer the situations in which method-a ought to be called, which means this will not be a helpful spec for JavaMOP.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-16-13",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 148,
        "inspection-start-time": "2022-02-07-16-34",
        "project": "commons-exec",
        "spec-id": "00349",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.Executor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00349.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutorTest.java:117",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory/snippet",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. The only implementation of method-b does not access/modify/affect that field variable (it checks whether the argument exitValue signifies that the subprocess has failed by using the field variable DefaultExecutor.exitValues), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-16-36",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 149,
        "inspection-start-time": "2022-02-07-19-08",
        "project": "commons-exec",
        "spec-id": "00358",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createProcessOutputPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.setProcessErrorStream(Ljava/io/InputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00358.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:116",
                        "method-b-site": "DefaultExecutor.java:363",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Commenting out method-a does not cause this test to fail"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "method-a modifies the field variable PumpStreamHandler.outputThread (it is a non-pure setter), and the only implementation of method-b modifies the field variable PumpStreamHandler.errorThread (also not a pure setter). Since these two field variables are not directly related, this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-19-13",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 150,
        "inspection-start-time": "2022-02-07-19-25",
        "project": "commons-exec",
        "spec-id": "00361",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createProcessOutputPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.PumpStreamHandler.createProcessErrorPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 37,
        "code-snippets-file": "snippets/ls/00361.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:116",
                        "method-b-site": "PumpStreamHandler.java:129",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Commenting out method-a does not cause this test to fail"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "method-a modifies the field variable PumpStreamHandler.outputThread, and method-b modifies the field variable PumpStreamHandler.errorThread (both are not pure setters). Since these two field variables are not directly related, this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-19-28",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 151,
        "inspection-start-time": "2022-02-07-20-49",
        "project": "commons-exec",
        "spec-id": "00363",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createSystemInPump(Ljava/io/InputStream;Ljava/io/OutputStream;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.setProcessErrorStream(Ljava/io/InputStream;)V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00363.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec33Test#testExec33",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:143",
                        "method-b-site": "DefaultExecutor.java:363",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is somewhat weak for evaluating method-a because the script that it runs doesn't take in anything from input. (It somewhat makes sense because the input stream specified is Standard in, which means that someone needs to type in the input... but still)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec33Test#testExec33/snippet",
        "notes": "method-a modifies the field variables PumpStreamHandler.inputStreamPumper, and its return value gets set to the field variable PumpStreamHandler.inputThread. The only implementation of method-b modifies the field variable PumpStreamHandler.errorThread (it is not a pure setter). Since the field variable modified by method-b is not directly related to those modified/affected by method-a, this is a spurious spec - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-20-55",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 152,
        "inspection-start-time": "2022-02-07-20-55",
        "project": "commons-exec",
        "spec-id": "00364",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createSystemInPump(Ljava/io/InputStream;Ljava/io/OutputStream;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.setProcessOutputStream(Ljava/io/InputStream;)V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00364.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec33Test#testExec33",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:143",
                        "method-b-site": "DefaultExecutor.java:362",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is somewhat weak for evaluating method-a because the script that it runs doesn't take in anything from input. (It somewhat makes sense because the input stream specified is Standard in, which means that someone needs to type in the input... but still)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec33Test#testExec33/snippet",
        "notes": "method-a modifies the field variables PumpStreamHandler.inputStreamPumper, and its return value gets set to the field variable PumpStreamHandler.inputThread. The only implementation of method-b modifies the field variable PumpStreamHandler.outputThread (not a pure setter). Since the field variable modified by method-b is not directly related to those modified/affected by method-a, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-20-58",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 153,
        "inspection-start-time": "2022-02-07-20-58",
        "project": "commons-exec",
        "spec-id": "00365",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createSystemInPump(Ljava/io/InputStream;Ljava/io/OutputStream;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.start()V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00365.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec33Test#testExec33",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:143",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is somewhat weak for evaluating method-a because the script that it runs doesn't take in anything from input. (It somewhat makes sense because the input stream specified is Standard in, which means that someone needs to type in the input... but still)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec33Test#testExec33",
        "notes": "method-a modifies the field variables PumpStreamHandler.inputStreamPumper that copies the input stream, and its return value gets set to the field variable PumpStreamHandler.inputThread. The only implementation of method-b only starts the thread in PumpStreamHandler.inputThread if it has been initialized. So, if method-a was not called before method-b, the parent process will not have any handle on the input stream of the subprocess. DECISION: This seems like a case of CONNECTION_DOES_NOT_NECESSITATE_ORDERING and TRUE_SPEC_WITH_CALLER case, given that method-a by itself creates and returns a Thread and can be called after the call to method-b. Plus, method-a may not be called in all invocations of PumpStreamHandler.setProcessInputStream().",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-21-09",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 154,
        "inspection-start-time": "2022-02-07-21-09",
        "project": "commons-exec",
        "spec-id": "00366",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createSystemInPump(Ljava/io/InputStream;Ljava/io/OutputStream;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.stop()V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00366.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec33Test#testExec33",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:143",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is somewhat weak for evaluating method-a because the script that it runs doesn't take in anything from input. (It somewhat makes sense because the input stream specified is Standard in, which means that someone needs to type in the input... but still)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec33Test#testExec33",
        "notes": "method-a modifies the field variables PumpStreamHandler.inputStreamPumper that copies the input stream, and its return value gets set to the field variable PumpStreamHandler.inputThread. The only implementation of b stops the PumpStreamHandler.inputStreamPumper if it is set, and stops the thread PumpStreamHandler.inputThread. I think this establishes a sort of postcondition in the sense that one ought to stop the field variable PumpStreamHandler.inputStreamPumper when it is no longer needed. However, for PumpStreamHandler.inputThread, it seems that there is a stronger relationship between the caller of method-a and ExecuteStreamHandler.start(), and between ExecuteStreamHandler.start() and method-b, instead of between method-a and method-b. DECISION: This seems like a case of CONNECTION_DOES_NOT_NECESSITATE_ORDERING, given that method-a by itself creates and returns a Thread and can technically be called after the call to method-b without inducing any faults. The use case shows a connection between method-a and method-b, but the methods themselves are not related.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-21-16",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 155,
        "inspection-start-time": "2022-02-07-21-16",
        "project": "commons-exec",
        "spec-id": "00367",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createSystemInPump(Ljava/io/InputStream;Ljava/io/OutputStream;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.PumpStreamHandler.createProcessErrorPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00367.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec33Test#testExec33",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:143",
                        "method-b-site": "PumpStreamHandler.java:129",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is somewhat weak for evaluating method-a because the script that it runs doesn't take in anything from input. (It somewhat makes sense because the input stream specified is Standard in, which means that someone needs to type in the input... but still)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet/notes below",
        "notes": "method-a modifies the field variables PumpStreamHandler.inputStreamPumper, and its return value gets set to the field variable PumpStreamHandler.inputThread. The only implementation of method-b modifies the field variable PumpStreamHandler.errorThread (it is not a pure setter). Since the field variable modified by method-b is not directly related to those modified/affected by method-a, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-21-19",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 156,
        "inspection-start-time": "2022-02-07-21-19",
        "project": "commons-exec",
        "spec-id": "00368",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createSystemInPump(Ljava/io/InputStream;Ljava/io/OutputStream;)Ljava/lang/Thread;",
        "method-b": "org.apache.commons.exec.PumpStreamHandler.createProcessOutputPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-a-return-type": "java.lang.Thread",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00368.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec33Test#testExec33",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:143",
                        "method-b-site": "PumpStreamHandler.java:116",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is somewhat weak for evaluating method-a because the script that it runs doesn't take in anything from input. (It somewhat makes sense because the input stream specified is Standard in, which means that someone needs to type in the input... but still)."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec33Test#testExec33",
        "notes": "method-a modifies the field variables PumpStreamHandler.inputStreamPumper, and its return value gets set to the field variable PumpStreamHandler.inputThread. The only implementation of method-b modifies the field variable PumpStreamHandler.outputThread (it is not a pure setter). Since the field variable modified by method-b is not directly related to those modified/affected by method-a, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-21-22",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 157,
        "inspection-start-time": "2022-02-07-21-41",
        "project": "commons-exec",
        "spec-id": "00371",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer.isEmpty()Z",
        "method-b": "org.apache.commons.exec.ProcessDestroyer.add(Ljava/lang/Process;)Z",
        "method-a-return-type": "boolean",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00371.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:502",
                        "method-b-site": "DefaultExecutor.java:378",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:502)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:378)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a simply checks whether the size of the field variable ShutdownHookProcessDestroyer.processes is equal to 0 (ONE_STATELESS_METHOD?). The only implementation of method-b, among other operations, adds an element to the field variable ShutdownHookProcessDestroyer.processes. So, the return value of method-a will change depending on whether method-b was called or not beforehand (among other factors, like whether removal happened). It might be a MORE_COMPLEX_THAN_AB spec? but it might also be a spurious-spec, given how method-a is only reactive to the state that method-b changes. Note: ShutdownHookProcessDestroyer.processes is defined at declaration and is a final variable, so method-a can quite literally be called anytime without concern of a NullPointerException DECISION: two public methods that one can call at any time",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-21-52",
        "inspection-time-in-minutes": 12
    },
    {
        "iid": 158,
        "inspection-start-time": "2022-02-07-21-52",
        "project": "commons-exec",
        "spec-id": "00372",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer.isEmpty()Z",
        "method-b": "org.apache.commons.exec.ProcessDestroyer.remove(Ljava/lang/Process;)Z",
        "method-a-return-type": "boolean",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00372.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:502",
                        "method-b-site": "DefaultExecutor.java:439",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:502)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:439)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a simply checks whether the size of the field variable ShutdownHookProcessDestroyer.processes is equal to 0 (ONE_STATELESS_METHOD?). The only implementation of method-b, among other operations, attempts to remove an element from the field variable ShutdownHookProcessDestroyer.processes. So, the return value of method-a will change depending on whether method-b was called or not beforehand (among other factors, like whether removal happened). It might be a MORE_COMPLEX_THAN_AB spec? but it might also be a spurious-spec, given how method-a is only reactive to the state that method-b changes. Note: ShutdownHookProcessDestroyer.processes is defined at declaration and is a final variable, so method-a can quite literally be called anytime without concern of a NullPointerException. DECISION two public methods that one can call at any time",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-21-58",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 159,
        "inspection-start-time": "2022-02-07-21-58",
        "project": "commons-exec",
        "spec-id": "00373",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer.isEmpty()Z",
        "method-b": "org.apache.commons.exec.ShutdownHookProcessDestroyer.addShutdownHook()V",
        "method-a-return-type": "boolean",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00373.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:502",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:86",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:502)\nb @ Thd[27]Obj[0]:0(ShutdownHookProcessDestroyer.java:86)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippets",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a simply checks whether the size of the field variable ShutdownHookProcessDestroyer.processes is equal to 0. method-b does not access/modify/affect that field variable (method-b creates a new ProcessDestroyerImpl object and adds it to the collection of shutdown hooks), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-22-01",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 160,
        "inspection-start-time": "2022-02-07-22-01",
        "project": "commons-exec",
        "spec-id": "00374",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer.isEmpty()Z",
        "method-b": "org.apache.commons.exec.ShutdownHookProcessDestroyer.removeShutdownHook()V",
        "method-a-return-type": "boolean",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00374.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:502",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:135",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:502)\nb @ Thd[27]Obj[0]:0(ShutdownHookProcessDestroyer.java:86)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippets",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a simply checks whether the size of the field variable ShutdownHookProcessDestroyer.processes is equal to 0. method-b does not access/modify/affect that field variable (method-b removes the shutdown hook from the runtime), so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-22-03",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 161,
        "inspection-start-time": "2022-02-07-22-41",
        "project": "commons-exec",
        "spec-id": "00377",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer$ProcessDestroyerImpl.start()V",
        "method-b": "org.apache.commons.exec.ShutdownHookProcessDestroyer$ProcessDestroyerImpl.join(J)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00377.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ShutdownHookProcessDestroyer.java:156",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:159",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "This is actually a spec between Thread.start() and Thread.join(), which seems a bit out of scope. It seems that if one calls method-b before method-a, method-b will return immediately instead of waiting for the thread that would be started by method-a (a non-started thread) to finish? DECISION these calls mirror a spec in the superclass (Thread)",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-22-45",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 162,
        "inspection-start-time": "2022-02-07-22-45",
        "project": "commons-exec",
        "spec-id": "00378",
        "method-a": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00378.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Watchdog.java:56",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:420)\na @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "NA",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG + SUPPLEMENTARY_EVIDENCE_BY_JAVADOC: The implementation of method-a is one of two locations in ExecuteWatchdog that can modify the field variable ExecuteWatchdog.caught - it sets the variable when it catches an exception from the process as it either checks that it has terminated, or kills it itself. The call to DebugUtils.handleException() from method-a doesn't necessarily throw the exception. method-b checks whether the field variable ExecuteWatchdog.caught was set, and throws it in the case that it was. So, it seems that method-b ought to be called so that the watchdog can re-throw the exception that the subprocess threw (if it did)? Decision: documented in Javadoc",
        "findings": "Type-a: method-a is always followed by method-b",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-23-06",
        "inspection-time-in-minutes": 21
    },
    {
        "iid": 163,
        "inspection-start-time": "2022-02-07-23-15",
        "project": "commons-exec",
        "spec-id": "00381",
        "method-a": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.ensureStarted()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 1,
        "code-snippets-file": "snippets/ls/00381.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Watchdog.java:56",
                        "method-b-site": "ExecuteWatchdog.java:209",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(ExecuteWatchdog.java:209)\na @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: The implementation of method-a is called once the timeout on the watchdog is reached (unless if the watchdog is stopped beforehand). It checks whether the process was already stopped, and kills the process and does some postprocessing if not. It seems to me that method-b will always not enter the while loop after method-a is called and before ExecuteWatchdog.setProcessNotStarted() is potentially called (as by the point that method-b is called, ExecuteWatchdog.processStarted must be true; or ExecuteWatchdog.caught will be set via ExecuteWatchdog.failedToStart() if the subject process could not start in the first place). So I don't really see the point of calling method-b before or after method-a? Flagging this as a spurious spec, but would be open to changing my mind about this.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-23-28",
        "inspection-time-in-minutes": 13
    },
    {
        "iid": 164,
        "inspection-start-time": "2022-02-07-23-29",
        "project": "commons-exec",
        "spec-id": "00382",
        "method-a": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.isWatching()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00382.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Watchdog.java:56",
                        "method-b-site": "Exec34Test.java:88",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:88)\na @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "both",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: The only implementation of method-a is called once the timeout on the watchdog is reached (unless if the watchdog is stopped beforehand). It checks whether the process was already stopped, and kills the process and does some postprocessing if not. method-b checks for the field variables ExecuteWatchdog.processStarted, ExecuteWatchdog.caught, and the returns the field variable ExecuteWatchdog.watch. method-a sets ExecuteWatchdog.watch to false. I can see two use cases for these two methods: (1) method-b is called before method-a to ensure that the watchdog is still monitoring a process before it reaches its timeout, (2) method-b is called after method-a to ensure that after method-a is called, the watchdog is no longer monitoring the process (this is the use case of the test). So, this seems like a \"b*ab*\" kind of spec instead? MORE_COMPLEX_THAN_AB. DECISION: two public method calls that one can call in any order",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-23-34",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 165,
        "inspection-start-time": "2022-02-07-23-34",
        "project": "commons-exec",
        "spec-id": "00383",
        "method-a": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.killedProcess()Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "code-snippets-file": "snippets/ls/00383.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Watchdog.java:56",
                        "method-b-site": "Exec34Test.java:87",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[1]Obj[0]:0(Exec34Test.java:87)\na @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: The only implementation of method-a is called once the timeout on the watchdog is reached (unless if the watchdog is stopped beforehand). It checks whether the process was already stopped, and kills the process and does some postprocessing, including setting ExecuteWatchdog.killedProcess to true, if not. ONE_STATELESS_METHOD: method-b is a 1-line getter to the field variable ExecuteWatchdog.killedProcess. So, if method-a did actually kill the process, the return value of method-b would differ from if it did not (meaning that method-a influences the return value of method-b). Hence, this is a true spec. (But calling method-b is not a requirement following method-a CONNECTION_DOES_NOT_NECESSITATE_ORDERING)",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-23-39",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 166,
        "inspection-start-time": "2022-02-07-23-39",
        "project": "commons-exec",
        "spec-id": "00384",
        "method-a": "org.apache.commons.exec.TimeoutObserver.timeoutOccured(Lorg/apache/commons/exec/Watchdog;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 4,
        "code-snippets-file": "snippets/ls/00384.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Watchdog.java:56",
                        "method-b-site": "DefaultExecutor.java:402",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:402)\na @ Thd[31]Obj[0]:0(Watchdog.java:56)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: The only implementation of method-a is called once the timeout on the watchdog is reached (unless if the watchdog is stopped beforehand). It checks whether the process was already stopped, and kills the process and does some postprocessing, including setting ExecuteWatchdog.killedProcess to true, if not. method-b stops the watcher and notify all threads that may be waiting on the thread. It seems like the implementation of method-a and method-b roughly achieve the same effect in setting ExecuteWatchdog.watch to false and ExecuteWatchdog.process to null. method-b does stop ExecuteWatchdog.watchdog, but it seems like by the time that method-a is reached, the function of the watchdog is over? That being said, method-b does make Watchdog.stopped = true. It seems like calling method-b before method-a is entirely possible in a case where the subproces completes before the timeout via the watchdog is achieved. So, all in all, I think there is no strict temporal ordering between the two methods.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-23-49",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 167,
        "inspection-start-time": "2022-02-07-23-54",
        "project": "commons-exec",
        "spec-id": "00386",
        "method-a": "org.apache.commons.exec.Watchdog.addTimeoutObserver(Lorg/apache/commons/exec/TimeoutObserver;)V",
        "method-b": "org.apache.commons.exec.Watchdog.fireTimeoutOccured()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00386.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:90",
                        "method-b-site": "Watchdog.java:91",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:90)\nb @ Thd[27]Obj[0]:0(Watchdog.java:91)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a adds an element to the field variable Watchdog.observers, and method-b iterates over the field variable Watchdog.observers to call TimeoutObserver.timeoutOccured() on each element. So, it seems paramount that method-a be called before method-b; otherwise, a watchdog may be missing from the set that need to be fired to kill the timed-out subproces (which may lead to an infinite loop).",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-08-00-03",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 168,
        "inspection-start-time": "2022-02-08-00-03",
        "project": "commons-exec",
        "spec-id": "00387",
        "method-a": "org.apache.commons.exec.Watchdog.addTimeoutObserver(Lorg/apache/commons/exec/TimeoutObserver;)V",
        "method-b": "org.apache.commons.exec.Watchdog.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 10,
        "code-snippets-file": "snippets/ls/00387.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:90",
                        "method-b-site": "ExecuteWatchdog.java:120",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(ExecuteWatchdog.java:90)\nb @ Thd[27]Obj[0]:0(ExecuteWatchdog.java:120)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a adds an element to the field variable Watchdog.observers. method-b creates and starts a new thread to run the Watchdog object it is called on (so, the thread runs Watchdog.run()). I think the critical point at which method-a needs to be called is by Watchdog.fireTimeoutOccurred(), because that's where the field variable Watchdog.observers is used. Because the call to method-b is before that point, I think this is technically a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-08-00-14",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 169,
        "inspection-start-time": "2022-02-08-00-25",
        "project": "commons-exec",
        "spec-id": "00389",
        "method-a": "org.apache.commons.exec.Watchdog.fireTimeoutOccured()V",
        "method-b": "org.apache.commons.exec.Watchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 4,
        "code-snippets-file": "snippets/ls/00389.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Watchdog.java:91",
                        "method-b-site": "ExecuteWatchdog.java:142",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\nb @ Thd[27]Obj[0]:0(ExecuteWatchdog.java:142)\na @ Thd[31]Obj[0]:0(Watchdog.java:91)\n. Given this, there are two observations: (1) b is called before a in this specialized trace, and (2) the threads in which the two methods occurred are different. INSPECTION_TODO to figure out why this happened on the two sanity check runs, but not when the spec was mined?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + POSSIBLE_DSI_BUG: method-a is called once the timeout on the watchdog is reached (unless if the watchdog is stopped beforehand). It calls TimeoutObserver.timeoutOccurred() on each element of Watchdog.observers. The only implementation of TimeoutObserver.timeoutOccurred() checks whether the process was already stopped, and kills the process and does some postprocessing, including setting ExecuteWatchdog.killedProcess to true, if not. method-b stops the watcher and notify all threads that may be waiting on the thread. method-b does stop ExecuteWatchdog.watchdog, but it seems like by the time that method-a is reached, the job of the watchdog is over? That being said, method-b makes Watchdog.stopped = true. It seems that calling method-b before method-a is entirely possible if the subproces completes before the timeout via the watchdog is achieved. So, I think there is no strict temporal ordering between the two methods.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-08-00-32",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 170,
        "inspection-start-time": "2022-02-08-00-32",
        "project": "commons-exec",
        "spec-id": "00390",
        "method-a": "org.apache.commons.exec.Watchdog.start()V",
        "method-b": "org.apache.commons.exec.Watchdog.fireTimeoutOccured()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "code-snippets-file": "snippets/ls/00390.java",
        "inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec34Test#testExec34_2",
                "stage": "sanity-check-failure",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:120",
                        "method-b-site": "Watchdog.java:91",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[27]Obj[0]:0(ExecuteWatchdog.java:120)\nb @ Thd[31]Obj[0]:0(Watchdog.java:91)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this?"
            }
        ],
        "verdict": "no-break-pass (indirect)",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "snippet",
        "notes": "CONCURRENCY + GOOD_EXAMPLE: method-a starts a new thread that runs the current Watchdog instance; meaning that the thread runs Watchdog.run(). The caller of method-b is that same Watchdog.run(), so one simply cannot call method-b without calling method-a. So, this seems like a special kind of NBP. SPECIAL_NBP",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-08-00-37",
        "inspection-time-in-minutes": 5
    }
]
