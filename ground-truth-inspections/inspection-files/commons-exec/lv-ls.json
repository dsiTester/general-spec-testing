[
    {
        "iid": 1,
        "inspection-start-time": "2022-02-02-20-18",
        "project": "commons-exec",
        "spec-id": "00006",
        "method-a": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-b": "org.apache.commons.exec.CommandLine.getArguments()[Ljava/lang/String;",
        "method-a-return-type": "org.apache.commons.exec.CommandLine",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 3,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00006.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithArg",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "The test failed because it checked for the output of the script, which was supposed to include its first argument; however, since method-a was delayed, the output differed from what was expected."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "GOOD_EXAMPLE + EXPECTED_EXCEPTION. Note that the script does produce some error messages - \"sleep: missing operand\", and the error code that the script produces is different from when method-a is delayed (1) and when method-a is not delayed (143). So, the expected exception seems like a weak oracle here."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithArg",
        "notes": "method-a adds an argument to the field variable CommandLine.arguments, and method-b retrieves the list of arguments using the field variable CommandLine.arguments. Hence, if method-a wasn't called before method-b, an argument would be missing from the script.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-02-20-29",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 2,
        "inspection-start-time": "2022-02-02-20-29",
        "project": "commons-exec",
        "spec-id": "00007",
        "method-a": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-b": "org.apache.commons.exec.CommandLine.getExecutable()Ljava/lang/String;",
        "method-a-return-type": "org.apache.commons.exec.CommandLine",
        "method-b-return-type": "java.lang.String",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 3,
        "LS-verdict-count": 2,
        "code-snippets-file": "snippets/lv-ls/00007.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithArg",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "CommandLine.java:298",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED.",
                "notes": "The test failed because it checked for the output of the script, which was supposed to include its first argument; however, since method-a was delayed, the output differed from what was expected. DELAY_CAUSES_OUTPUT_CORRUPTION"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "CommandLine.java:298",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "EXPECTED_EXCEPTION. Note that the script does produce some error messages - \"sleep: missing operand\", and the error code that the script produces is different from when method-a is delayed (1) and when method-a is not delayed (143). So, the expected exception seems like a weak oracle here."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
        "notes": "The critical point for method-a to be called by is CommandLine.java:297, and method-b happened to be after that specific point, which is why the validating test failed (METHOD_B_AFTER_CRITICAL_POINT). In general, method-a adds a new String to the field variable CommandLine.arguments, and method-b retrieves the executable (which is not related to the arguments). So, there is no relation between method-a and method-b themselves - UNRELATED_STATEFUL_METHODS.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-02-20-36",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 3,
        "inspection-start-time": "2022-02-02-20-39",
        "project": "commons-exec",
        "spec-id": "00009",
        "method-a": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-b": "org.apache.commons.exec.CommandLine.toStrings()[Ljava/lang/String;",
        "method-a-return-type": "org.apache.commons.exec.CommandLine",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 3,
        "LS-verdict-count": 2,
        "code-snippets-file": "snippets/lv-ls/00009.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithArg",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "Java13CommandLauncher.java:60",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "The test failed because it checked for the output of the script, which was supposed to include its first argument; however, since method-a was delayed, the output differed from what was expected."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:226",
                        "method-b-site": "Java13CommandLauncher.java:60",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "RETURN_VALUE_DISCARDED - refer to snippet.",
                "notes": "EXPECTED_EXCEPTION. Note that the script does produce some error messages - \"sleep: missing operand\", and the error code that the script produces is different from when method-a is delayed (1) and when method-a is not delayed (143). So, the expected exception seems like a weak oracle here."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithArg",
        "notes": "method-a adds an argument to the field variable CommandLine.arguments, and method-b retrieves the list of arguments using the field variable CommandLine.arguments. Hence, if method-a wasn't called before method-b, an argument would be missing from the script.",
        "findings": "may be sts. Type-c: method-b is always/sometimes preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-02-20-43",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 4,
        "inspection-start-time": "2022-02-02-22-26",
        "project": "commons-exec",
        "spec-id": "00020",
        "method-a": "org.apache.commons.exec.CommandLine$Argument.getValue()Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine$Argument.isHandleQuoting()Z",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 6,
        "test-methods-mine-count": 22,
        "LV-verdict-count": 21,
        "LS-verdict-count": 4,
        "code-snippets-file": "snippets/lv-ls/00020.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithArg",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:423",
                        "method-b-site": "CommandLine.java:423",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "DSI most likely replaced the return value of method-a with the String variable expandedArgument, which was not set at the time that method-b was called, so effectively the return value of method-a was replaced with null. This caused the return value of the caller of method-a and method-b to return an incorrect value, causing the test to fail.",
                "notes": ""
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithComplexArguments",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:423",
                        "method-b-site": "CommandLine.java:423",
                        "invocation-count": 2
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "DSI most likely replaced the return value of method-a with the String variable expandedArgument, which was not set at the time that method-b was called, so effectively the return value of method-a was replaced with null.",
                "notes": "The test passes because the test simply checks that the execution of the script didn't fail. Moreover, the script didn't fail despite lacking an argument because all script itself does is that it simply prints its arguments."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "UNRELATED_STATELESS_METHODS - method-a is a 1-line naive getter to the field variable Argument.value, and method-b is a 1-line naive getter to the field variable Argument.handleQuoting. INSPECTION_TODO: the tracking of method-a and method-b sites seems broken here? The line that the sites point to is the declaration of the Argument class (POSSIBLE_DSI_BUG).",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-02-22-49",
        "inspection-time-in-minutes": 23
    },
    {
        "iid": 5,
        "inspection-start-time": "2022-02-02-23-41",
        "project": "commons-exec",
        "spec-id": "00021",
        "method-a": "org.apache.commons.exec.CommandLine.expandArgument(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.getArguments()[Ljava/lang/String;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 29,
        "LV-verdict-count": 24,
        "LS-verdict-count": 2,
        "code-snippets-file": "snippets/lv-ls/00021.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:149",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message shows that the return value of method-a was replaced by \"\" (the empty string), but I don't see the empty string in scope?",
                "notes": "IOException thrown because there is no command to be run (because method-a was replaced with the empty string)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplication",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:149",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message shows that the return value of method-a was replaced by \"\" (the empty string), but I don't see the empty string in scope?",
                "notes": "EXPECTED_EXCEPTION - the exception that was thrown because of DSI's delays was swallowed by the test expecting an IOException."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute with modifications propsed in snippet",
        "notes": "ONE_STATELESS_METHOD: method-a simply returns the expanded version of the argument String, and method-b retrieves the list of arguments that ought to be called in the command line. Note that method-b actually calls method-a (so we're kind of dealing with a nbp), but neither of these tests go into the loop where method-b calls method-a. ",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-00-12",
        "inspection-time-in-minutes": 31
    },
    {
        "iid": 6,
        "inspection-start-time": "2022-02-03-00-42",
        "project": "commons-exec",
        "spec-id": "00024",
        "method-a": "org.apache.commons.exec.CommandLine.getExecutable()Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.getArguments()[Ljava/lang/String;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 48,
        "LV-verdict-count": 46,
        "LS-verdict-count": 2,
        "code-snippets-file": "snippets/lv-ls/00024.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:298",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message shows that the return value of method-a was replaced by \"\" (the empty string), but I don't see the empty string in scope?",
                "notes": "IOException thrown because there is no command to be run (because method-a was replaced with the empty string)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplication",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:298",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message shows that the return value of method-a was replaced by \"\" (the empty string), but I don't see the empty string in scope?",
                "notes": "EXPECTED_EXCEPTION - the exception that was thrown because of DSI's delays was swallowed by the test expecting an IOException."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute with modifications propsed in snippet",
        "notes": "ONE_STATELESS_METHOD: method-a simply returns the expanded version of the argument String, and method-b retrieves the list of arguments that ought to be called in the command line. method-b doesn't affect method-a, so this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-00-46",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 7,
        "inspection-start-time": "2022-02-03-00-56",
        "project": "commons-exec",
        "spec-id": "00029",
        "method-a": "org.apache.commons.exec.CommandLine.setSubstitutionMap(Ljava/util/Map;)V",
        "method-b": "org.apache.commons.exec.CommandLine.getArguments()[Ljava/lang/String;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 7,
        "LV-verdict-count": 2,
        "LS-verdict-count": 6,
        "code-snippets-file": "snippets/lv-ls/00029.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testParseComplexCommandLine1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:88",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails here because method-a sets CommandLine.substitutionMap to a map with two elements of which keys are \"in\" and \"out\". When method-b executed, it didn't know to substitute \"in\" with the corresponding value; hence the test failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testParseComplexCommandLine2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:88",
                        "method-b-site": "CommandLineTest.java:283",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test passes here because method-a is a no-op because its argument was null."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testParseComplexCommandLine1",
        "notes": "method-a is a pure setter for the field variable CommandLine.substitutionMap, and method-b accesses CommandLine.substitutionMap in order to figure out where string substitution for variables in the command line need to be done. Hence, this is a true spec.",
        "findings": "May be sts. Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-01-10",
        "inspection-time-in-minutes": 14
    },
    {
        "iid": 8,
        "inspection-start-time": "2022-02-03-01-26",
        "project": "commons-exec",
        "spec-id": "00031",
        "method-a": "org.apache.commons.exec.CommandLine.setSubstitutionMap(Ljava/util/Map;)V",
        "method-b": "org.apache.commons.exec.CommandLine.toStrings()[Ljava/lang/String;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 5,
        "LV-verdict-count": 2,
        "LS-verdict-count": 4,
        "code-snippets-file": "snippets/lv-ls/00031.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testParseComplexCommandLine1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:88",
                        "method-b-site": "CommandLine.java:312",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails here because method-a sets CommandLine.substitutionMap to a map with two elements of which keys are \"in\" and \"out\". When method-b executed, it didn't know to substitute \"in\" with the corresponding value; hence the test failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testToString",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:88",
                        "method-b-site": "CommandLine.java:312",
                        "invocation-count": 3
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "GOOD_EXAMPLE + DSI_GOT_LUCKY_CASES: The test passes here because method-a sets CommandLine.substitutionMap to a size 0 map in the first invocation of method-a, so no contents of the map were missing following the delay of method-a; the other calls to method-a have a size >0 map (and hence if the delay occurred in any of those cases, the test would have failed), so DSI got lucky in choosing the first perturbation."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testParseComplexCommandLine1",
        "notes": "method-a is a pure setter for the field variable CommandLine.substitutionMap (ONE_PURE_SETTER), and method-b accesses CommandLine.substitutionMap in order to figure out where string substitution for variables in the command line (including the executable) needs to be done. Hence, this is a true spec.",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-01-33",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 9,
        "inspection-start-time": "2022-02-03-01-33",
        "project": "commons-exec",
        "spec-id": "00032",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;)Lorg/apache/commons/exec/CommandLine;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "org.apache.commons.exec.CommandLine",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 13,
        "LV-verdict-count": 6,
        "LS-verdict-count": 5,
        "code-snippets-file": "snippets/lv-ls/00032.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddArgumentWithBothQuotes",
                "stage": "stage-1-f2-precond",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLineTest.java:140",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - Most likely replaced the return value of method-a with null?",
                "notes": "The DSI experiment resulted in stage-1 but the test passed because method-b threw the EXPECTED_EXCEPTION."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddNullArgument",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLineTest.java:91",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - Most likely replaced the return value of method-a with null?",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testAddNullArgument/snippets",
        "notes": "In the constructor of CommandLine that both tests use, the return value of method-a is set as the field variable CommandLine.executable; method-b adds an item to the field variable CommandLine.addArgument, which is not related to CommandLine.executable. So, this is most likely a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-43",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 10,
        "inspection-start-time": "2022-02-03-01-43",
        "project": "commons-exec",
        "spec-id": "00033",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.addArgument(Ljava/lang/String;Z)Lorg/apache/commons/exec/CommandLine;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "org.apache.commons.exec.CommandLine",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 11,
        "LV-verdict-count": 5,
        "LS-verdict-count": 3,
        "code-snippets-file": "snippets/lv-ls/00033.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddArgumentWithBothQuotes",
                "stage": "stage-1-f2-precond",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLine.java:226",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - Most likely replaced the return value of method-a with null?",
                "notes": "The DSI experiment resulted in stage-1 but the test passed because method-b threw the EXPECTED_EXCEPTION."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testAddNullArgument",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLine.java:226",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR -Most likely replaced the return value of method-a with null?",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.CommandLineTest#testAddNullArgument/snippets",
        "notes": "In the constructor of CommandLine that both tests use, the return value of method-a is set as the field variable CommandLine.executable; method-b adds an item to the field variable CommandLine.addArgument, which is not related to CommandLine.executable. So, this is most likely a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-01-45",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 11,
        "inspection-start-time": "2022-02-03-01-58",
        "project": "commons-exec",
        "spec-id": "00038",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.expandArgument(Ljava/lang/String;)Ljava/lang/String;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.lang.String",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 29,
        "LV-verdict-count": 20,
        "LS-verdict-count": 6,
        "code-snippets-file": "snippets/lv-ls/00038.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:149",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message suggests that the return value of method-a was replaced by \"\" (the empty string), but I can't find a variable in scope assigned to the empty string.",
                "notes": "The test fails because the command that is supposed to be run is invalid,  because method-a didn't execute and thus the field variable CommandLine.executable got set to the replacement value. The exception was thrown because it couldn't find an executable name called \"\" in the directory."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:149",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR (can't get the replacement value from anywhere, but can assume it's the same as with the validating test?)",
                "notes": "EXPECTED_EXCEPTION (the exception will be thrown after method-b) - however, this exception is the same exact one that was thrown by the validating-test when method-a was delayed. Essentially, the exception was thrown because the executable that should have been run (which is retrieved by CommandLine.getExecutable(), the caller of method-b) was not found. The test gives a bogus executable name to test that this happens in. Manually replacing method-a with \"\" causes the exception message to differ, but since this test doesn't check for the error message, this seems like a weak oracle."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
        "notes": "The connection between the two methods in this use case is mostly from method-b's argument being the field variable CommandLine.executable, which is set to the return value of method-a. method-a returns a modified version of the executable string so it can be set to CommandLine.executable, and method-b is a general method that replaces variables in a command line argument with their corresponding values. So, in general, method-a does not necessarily have to be called before method-b.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-02-16",
        "inspection-time-in-minutes": 18
    },
    {
        "iid": 12,
        "inspection-start-time": "2022-02-03-02-16",
        "project": "commons-exec",
        "spec-id": "00039",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.getArguments()[Ljava/lang/String;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 50,
        "LV-verdict-count": 30,
        "LS-verdict-count": 20,
        "code-snippets-file": "snippets/lv-ls/00039.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message suggests that the return value of method-a was replaced by \"\" (the empty string), but I can't find a variable in scope assigned to the empty string.",
                "notes": "The test fails because the command that is supposed to be run is invalid,  because method-a didn't execute and thus the field variable CommandLine.executable got set to the replacement value. The exception was thrown because it couldn't find an executable name called \"\" in the directory."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:299",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR (can't get the replacement value from anywhere, but can assume it's the same as with the validating test?)",
                "notes": "EXPECTED_EXCEPTION (the exception will be thrown after method-b) - however, this exception is the same exact one that was thrown by the validating-test when method-a was delayed. Essentially, the exception was thrown because the executable that should have been run (which is retrieved by CommandLine.getExecutable()) was not found. The test gives a bogus executable name to test that this exception is thrown. Manually replacing method-a with \"\" causes the exception message to differ, but since this test doesn't check for the error message, this seems like a weak oracle."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
        "notes": "method-a returns a modified version of the executable string, and its return value is set to CommandLine.executable (two out of three constructors of CommandLine sets CommandLine.executable to the return value of method-a; the third one is used to copy from an existing CommandLine object. CommandLine.executable is only set in these three constructors). method-b returns a String[] object using the data from the field variable CommandLine.arguments, which is not related to CommandLine.executable. So, this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-03-02-20",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 13,
        "inspection-start-time": "2022-02-03-02-20",
        "project": "commons-exec",
        "spec-id": "00040",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.getExecutable()Ljava/lang/String;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.lang.String",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 48,
        "LV-verdict-count": 30,
        "LS-verdict-count": 18,
        "code-snippets-file": "snippets/lv-ls/00040.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:298",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message suggests that the return value of method-a was replaced by \"\" (the empty string), but I can't find a variable in scope assigned to the empty string.",
                "notes": "The test fails because the command that is supposed to be run is invalid,  because method-a didn't execute and thus the field variable CommandLine.executable got set to the replacement value. The exception was thrown because it couldn't find an executable name called \"\" in the directory."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:298",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR (can't get the replacement value from anywhere, but can assume it's the same as with the validating test?)",
                "notes": "EXPECTED_EXCEPTION (the exception will be thrown after method-b) - however, this exception is the same exact one that was thrown by the validating-test when method-a was delayed. Essentially, the exception was thrown because the executable that should have been run (which is retrieved by method-b) was not found. The test gives a bogus executable name to test to ensure that this exception is thrown. Manually replacing method-a with \"\" causes the exception message to differ, but since this test doesn't check for the error message, this seems like a weak oracle."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables/snippet",
        "notes": "method-a returns a modified version of the executable string so it can be set to CommandLine.executable (two out of three constructors of CommandLine sets CommandLine.executable to the return value of method-a; the third one is used to copy from an existing CommandLine object. CommandLine.executable is only set in these three constructors). method-b accesses CommandLine.executable to form its return variable (a processed version of CommandLine.executable), so this is a true-spec",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-02-25",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 14,
        "inspection-start-time": "2022-02-03-02-30",
        "project": "commons-exec",
        "spec-id": "00041",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.getSubstitutionMap()Ljava/util/Map;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.util.Map",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 29,
        "LV-verdict-count": 20,
        "LS-verdict-count": 6,
        "code-snippets-file": "snippets/lv-ls/00041.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:324",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message suggests that the return value of method-a was replaced by \"\" (the empty string), but I can't find a variable in scope assigned to the empty string.",
                "notes": "The test fails because the command that is supposed to be run is invalid,  because method-a didn't execute and thus the field variable CommandLine.executable got set to the replacement value. The exception was thrown because it couldn't find an executable name called \"\" in the directory."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "CommandLine.java:324",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR (can't get the replacement value from anywhere, but can assume it's the same as with the validating test?)",
                "notes": "EXPECTED_EXCEPTION (the exception will be thrown after method-b) - however, this exception is the same exact one that was thrown by the validating-test when method-a was delayed. Essentially, the exception was thrown because the executable that should have been run (which is retrieved by CommandLine.getExecutable()) was not found. The test gives a bogus executable name to test that this exception is thrown. Manually replacing method-a with \"\" causes the exception message to differ, but since this test doesn't check for the error message, this seems like a weak oracle."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables/snippet",
        "notes": "method-a returns a modified version of the executable string so it can be set to CommandLine.executable (two out of three constructors of CommandLine sets CommandLine.executable to the return value of method-a; the third one is used to copy from an existing CommandLine object. CommandLine.executable is only set in these three constructors). ONE_STATELESS_METHOD - method-b is a 1-line naive getter for the field variable CommandLine.substitutionMap, which is not directly related to the operations of method-a (the return value of method-a could contain a substring that is in the return value of method-b, but that doesn't necessitate method-a being called before method-b: CONNECTION_DOES_NOT_NECESSITATE_ORDERING).",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-02-33",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 15,
        "inspection-start-time": "2022-02-03-15-36",
        "project": "commons-exec",
        "spec-id": "00042",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.setSubstitutionMap(Ljava/util/Map;)V",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 14,
        "LV-verdict-count": 3,
        "LS-verdict-count": 10,
        "code-snippets-file": "snippets/lv-ls/00042.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec36Test#testExec36_2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "Exec36Test.java:144",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message suggests that the return value of method-a was replaced by \"\" (the empty string), but I can't find a variable in scope assigned to the empty string.",
                "notes": "The test fails during the call to DefaultExecutor.execute() because there is no command to run (because method-a didn't execute, and thus CommandLine.executable was set to \"\", the replaced return value of method-a)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.CommandLineTest#testToString",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:103",
                        "method-b-site": "CommandLine.java:88",
                        "invocation-count": 3
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACE_RETURN_WITH_CORRECT_VALUE_NONASSERTION: Most likely replaced the return value of method-a with the String argument executable, which was the return value that method-a would have made in a normal execution.",
                "notes": ""
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "method-a returns a modified version of the executable string so it can be set to CommandLine.executable (the Constructor sets the field variable to the return value of method-a). method-b is a pure setter for the field variable CommandLine.substitutionMap, which is not directly related to the operations of method-a (the return value of method-a could contain a substring that is in the argument to method-b, but that doesn't necessitate method-a being called before method-b).",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-15-57",
        "inspection-time-in-minutes": 19
    },
    {
        "iid": 16,
        "inspection-start-time": "2022-02-03-16-07",
        "project": "commons-exec",
        "spec-id": "00043",
        "method-a": "org.apache.commons.exec.CommandLine.toCleanExecutable(Ljava/lang/String;)Ljava/lang/String;",
        "method-b": "org.apache.commons.exec.CommandLine.toStrings()[Ljava/lang/String;",
        "method-a-return-type": "java.lang.String",
        "method-b-return-type": "java.lang.String[]",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 48,
        "LV-verdict-count": 30,
        "LS-verdict-count": 18,
        "code-snippets-file": "snippets/lv-ls/00043.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "Java13CommandLauncher.java:60",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR - the error message suggests that the return value of method-a was replaced by \"\" (the empty string), but I can't find a variable in scope assigned to the empty string.",
                "notes": "The test fails because there is no command to run (because method-a didn't execute, and thus CommandLine.java"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDo",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "CommandLine.java:113",
                        "method-b-site": "Java13CommandLauncher.java:60",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "REPLACEMENT_VALUE_UNCLEAR (can't get the replacement value from anywhere, but can assume it's the same as with the validating test?)",
                "notes": "EXPECTED_EXCEPTION (the exception will be thrown after method-b) - however, this may be masking the differences that delaying method-a causes."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testAddEnvironmentVariables/snippet",
        "notes": "method-a returns a modified version of the executable string so it can be set to CommandLine.executable (the Constructor sets the field variable to the return value of method-a). method-b accesses CommandLine.executable to form its return variable (a processed version of CommandLine.executable), so this is a true-spec",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-03-16-10",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 17,
        "inspection-start-time": "2022-02-05-12-44",
        "project": "commons-exec",
        "spec-id": "00130",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setExitValues([I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "LV-verdict-count": 3,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00130.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "method-b guards the ExecuteException that was thrown during the DSI experiment; if method-b returns true, then the Exception is thrown. In the DSI experiment, method-b returns true because the valid exit value (that the process exited with) that was supposed to be set by method-a as valid was not set. INSPECTION_TODO: show where all these are happening in the snippets"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:229",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION - it seems like this test expects the exception that method-b is a guard against, and calling method-a here does not help with the exit value that the process returns (1), so an ExecuteException is thrown anyways."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1 shows the connection between method-a and method-b",
        "notes": "method-a is a non-pure setter to the field variable DefaultExecutor.exitValues (the series of valid exit values for the process to be considered as having exited successfully), and method-b checks that same field variable to determine whether the argument exit value implies that the process ended successfully. DECISION: This seems like a CONNECTION_DOES_NOT_NECESSITATE_ORDERING case, given that the user may not want/need to set exit values other than zero to be valid in the general case (method-a is simply an extra option for the user). Moreover, setting an exit value other than the default to be valid may actually lead to faults, given that using only the default as the only valid exit value is a well-established convention.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-13-05",
        "inspection-time-in-minutes": 21
    },
    {
        "iid": 18,
        "inspection-start-time": "2022-02-05-13-50",
        "project": "commons-exec",
        "spec-id": "00135",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 1,
        "LS-verdict-count": 11,
        "code-snippets-file": "snippets/lv-ls/00135.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler, which handles the input and output stream of the subprocess. Within the caller of method-b, DefaultExecutor.streamHandler gets a handle on the streams of the subprocess. method-b closes the streams for the subprocess. It does not make sense to call method-b before method-a, but I don't know whether the connection between the two methods is strong enough (there needs to be a step where DefaultExecutor.streamHandler is connected to the subprocess's streams (which is somewhat done in DefaultExecutor.java:361-363), which is the part done by method-b's caller). DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-14-32",
        "inspection-time-in-minutes": 42
    },
    {
        "iid": 19,
        "inspection-start-time": "2022-02-05-15-30",
        "project": "commons-exec",
        "spec-id": "00136",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 5,
        "LS-verdict-count": 7,
        "code-snippets-file": "snippets/lv-ls/00136.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler, which handles the input and output stream of the subprocess. The field variable DefaultExecutor.streamHandler is passed into method-b, where it gets a handle on the streams of the subproess, starts, and stops. Given that DefaultExecutor.streamHandler is passed into method-b in all invocations of method-b within the code, I think it's reasonable to say that this may be a sometimes true spec for when the user wants to redirect the output from the subprocess into an outputstream different from stdout and stderr (because the constructor of DefaultExecutorTest sets the field variable DefaultExecutor.streamHandler to a new PumpStreamHandler object, which simply sets the output streams to stdout and stderr). Alternatively, the real true-spec relationship may be between method-a and the caller of method-b, given that this particular relationship only holds because DefaultExecutor.streamHandler is passed into method-b as an argument.  DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-15-39",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 20,
        "inspection-start-time": "2022-02-05-15-39",
        "project": "commons-exec",
        "spec-id": "00137",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 5,
        "LS-verdict-count": 7,
        "code-snippets-file": "snippets/lv-ls/00137.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutorTest.java:559",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutorTest.java:602",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler, which handles the input and output stream of the subprocess. The callee of method-b passes in the field variable DefaultExecutor.streamHandler to DefaultExecutor.executeInternal(), where it gets a handle on the streams of the subproess, starts, and stops. I think it's reasonable to say that this is a sometimes true spec for when the user wants to redirect the output from the subprocess into an outputstream different from stdout and stderr (because the constructor of DefaultExecutorTest sets the field variable DefaultExecutor.streamHandler to a new PumpStreamHandler object, which simply sets the output streams to stdout and stderr). DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-15-46",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 21,
        "inspection-start-time": "2022-02-05-15-46",
        "project": "commons-exec",
        "spec-id": "00138",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 5,
        "LS-verdict-count": 7,
        "code-snippets-file": "snippets/lv-ls/00138.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler, which handles the input and output stream of the subprocess. method-b passes in the field variable DefaultExecutor.streamHandler to DefaultExecutor.executeInternal(), where it gets a handle on the streams of the subproess, starts, and stops. I think it's reasonable to say that this is a sometimes true spec for when the user wants to redirect the output from the subprocess into an outputstream different from stdout and stderr (because the constructor of DefaultExecutorTest sets the field variable DefaultExecutor.streamHandler to a new PumpStreamHandler object, which simply sets the output streams to stdout and stderr).  DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-15-48",
        "inspection-time-in-minutes": 2
    },
    {
        "iid": 22,
        "inspection-start-time": "2022-02-05-15-48",
        "project": "commons-exec",
        "spec-id": "00139",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 1,
        "LS-verdict-count": 11,
        "code-snippets-file": "snippets/lv-ls/00139.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter to the field variable DefaultExecutor.streamHandler, and method-b is a 1-line getter to the field variable DefaultExecutor.exceptionCaught, which holds an IOException that is being thrown. The caller of method-b takes DefaultExecutor.streamHandler in as a final argument streams, so any call to method-b will not make an impact on the variable streams (the call to the caller of method-b is the threshold at which method-a should have been called by). I don't think there is a specific relationship between method-a and method-b. Hence, this is a spurious spec. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-15-56",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 23,
        "inspection-start-time": "2022-02-05-15-56",
        "project": "commons-exec",
        "spec-id": "00140",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 1,
        "LS-verdict-count": 11,
        "code-snippets-file": "snippets/lv-ls/00140.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter to the field variable DefaultExecutor.streamHandler, and method-b is a 1-line getter to the field variable DefaultExecutor.exceptionCaught, which holds an IOException that is being thrown. The caller of method-b takes DefaultExecutor.streamHandler in as a final argument streams, so any call to method-b will not make an impact on the variable streams (the call to the caller of method-b is the threshold at which method-a should have been called by). I don't think there is a specific relationship between method-a and method-b. Hence, this is a spurious spec. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-15-59",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 24,
        "inspection-start-time": "2022-02-05-15-59",
        "project": "commons-exec",
        "spec-id": "00141",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 9,
        "LV-verdict-count": 1,
        "LS-verdict-count": 11,
        "code-snippets-file": "snippets/lv-ls/00141.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:558",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test was trying to read the output of running the process from the specified OutputStream object baos, but there was nothing written to baos because method-a was not called. Hence, when the assertion checked whether the string \"Finished reading from stdin\" was written to baos, it failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:601",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that the output of the DSI experiment differs in this test compared to the sanity checks, so the error that is caused by causing method-b after method-a does surface, but the test oracle doesn't catch this."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithNullOutErr",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter to the field variable DefaultExecutor.streamHandler, and method-b is a 1-line getter to the field variable DefaultExecutor.exceptionCaught, which holds an IOException that is being thrown. The caller of method-b takes DefaultExecutor.streamHandler in as a final argument streams, so any call to method-b will not make an impact on the variable streams (the call to the caller of method-b is the threshold at which method-a should have been called by). I don't think there is a specific relationship between method-a and method-b. Hence, this is a spurious spec. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-16-07",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 25,
        "inspection-start-time": "2022-02-05-16-11",
        "project": "commons-exec",
        "spec-id": "00143",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 4,
        "LV-verdict-count": 4,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00143.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. The test failed because the test exceeded the specified timeout (timeout = TEST_TIMEOUT), because DefaultExecutor.watchdog was supposed to come in and kill the process before the timeout, but it didn't because DefaultExecutor.watchdog was never started (because method-a was not called by DefaultExecutor.java:382)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:349",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but not related to the DSI experiment. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called at all."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b closes the input/output/error streams of the subprocess after it is terminated. These two methods are not related (although, it wouldn't make sense to call method-b before method-a, or method-a after method-b, since method-a ought to only be called before the process is started, and method-b ought to only be called after the process has terminated), so I think this is a spurious spec.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-16-28",
        "inspection-time-in-minutes": 17
    },
    {
        "iid": 26,
        "inspection-start-time": "2022-02-05-16-29",
        "project": "commons-exec",
        "spec-id": "00145",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 5,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00145.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. The test failed because the test exceeded the specified timeout (timeout = TEST_TIMEOUT), because DefaultExecutor.watchdog was supposed to come in and kill the process before the timeout, but it didn't because DefaultExecutor.watchdog was never started (because method-a was not called by DefaultExecutor.java:382)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:349",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown by method-b after the process safely exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b manages the watchdog by starting, stopping, etc, if it is initialized. (If the watchdog is not started, it cannot kill the process based on a timeout) Hence, this seems like a SOMETIMES_TRUE_SPEC for when the user wants to set a watchdog in order to stop the subprocess after a certain amount of time. DELAY_CAUSES_TIMEOUT",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-16-36",
        "inspection-time-in-minutes": 7
    },
    {
        "iid": 27,
        "inspection-start-time": "2022-02-05-16-37",
        "project": "commons-exec",
        "spec-id": "00146",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "LV-verdict-count": 5,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00146.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "Exec65Test.java:54",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. The test failed because the test exceeded the specified timeout (timeout = TEST_TIMEOUT), because DefaultExecutor.watchdog was supposed to come in and kill the process before the timeout, but it didn't because DefaultExecutor.watchdog was never started (because method-a was not called by DefaultExecutor.java:382)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:349",
                        "method-b-site": "DefaultExecutorTest.java:352",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b (more specifically, DefaultExecutor.executeInternal(), which is indirectly called by method-b) manages the watchdog by starting, stopping, etc, if it is initialized. (If the watchdog is not started, it cannot kill the process based on a timeout) Hence, this seems like a SOMETIMES_TRUE_SPEC for when the user wants to set a watchdog in order to stop the subprocess after a certain amount of time. DELAY_CAUSES_TIMEOUT",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-16-42",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 28,
        "inspection-start-time": "2022-02-05-16-43",
        "project": "commons-exec",
        "spec-id": "00147",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "LV-verdict-count": 5,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00147.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. The test failed because the test exceeded the specified timeout (timeout = TEST_TIMEOUT), because DefaultExecutor.watchdog was supposed to come in and kill the process before the timeout, but it didn't because DefaultExecutor.watchdog was never started (because method-a was not called by DefaultExecutor.java:382)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:349",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b (more specifically, DefaultExecutor.executeInternal(), which is called by method-b) manages the watchdog by starting, stopping, etc, if it is initialized. (If the watchdog is not started, it cannot kill the process based on a timeout) Hence, this seems like a SOMETIMES_TRUE_SPEC for when the user wants to set a watchdog in order to stop the subprocess after a certain amount of time. DELAY_CAUSES_TIMEOUT",
        "findings": "We can encode this spec in JavaMOP as: if the user initializes an ExecuteWatchdog object before calling method-b, then method-a ought to be called between these two methods. Then, we would be able to catch cases where the user intended to use a watchdog but did not connect the executor to the watchdog.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-05-16-46",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 29,
        "inspection-start-time": "2022-02-05-16-46",
        "project": "commons-exec",
        "spec-id": "00150",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 4,
        "LV-verdict-count": 4,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00150.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. The test failed because the test exceeded the specified timeout (timeout = TEST_TIMEOUT), because DefaultExecutor.watchdog was supposed to come in and kill the process before the timeout, but it didn't because DefaultExecutor.watchdog was never started (because method-a was not called by DefaultExecutor.java:382)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:349",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b is a 1-line naive getter for the field variable DefaultExecutor.exceptionCaught (ONE_STATELESS_METHOD), which is a field variable set only after the process is exited/killed. The caller of method-b manages the watchdog by starting, stopping, etc., if it is initialized. (If the watchdog is not started, it cannot kill the process based on a timeout) While one can argue that method-b may not be called if method-a is not called (the process runs forever), but I don't think that really necessitates a relationship between these two methods.  CONNECTION_DOES_NOT_NECESSITATE_ORDERING DELAY_CAUSES_TIMEOUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-16-56",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 30,
        "inspection-start-time": "2022-02-05-16-57",
        "project": "commons-exec",
        "spec-id": "00152",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 5,
        "LV-verdict-count": 4,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00152.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. The test failed because the test exceeded the specified timeout (timeout = TEST_TIMEOUT), because DefaultExecutor.watchdog was supposed to come in and kill the process before the timeout, but it didn't because DefaultExecutor.watchdog was never started (because method-a was not called by DefaultExecutor.java:382)."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:349",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b checks the exit value of the process against the field variable DefaultExecutor.exitValues (after the process is exited/killed). The caller of method-b manages the watchdog by starting, stopping, etc, if it is initialized. (If the watchdog is not started, it cannot kill the process based on a timeout) While one can argue that method-b may not be called if method-a is not called (the process runs forever), but I don't think that really necessitates a relationship between these two methods. DELAY_CAUSES_TIMEOUT CONNECTION_DOES_NOT_NECESSITATE_ORDERING",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-08",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 31,
        "inspection-start-time": "2022-02-05-17-08",
        "project": "commons-exec",
        "spec-id": "00153",
        "method-a": "org.apache.commons.exec.DefaultExecutor.setWatchdog(Lorg/apache/commons/exec/ExecuteWatchdog;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 1,
        "LS-verdict-count": 5,
        "code-snippets-file": "snippets/lv-ls/00153.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteNonExistingApplicationWithWatchDog",
                "stage": "stage-1-f2-precond",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:380",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The DSI experiment resulted in a stage-1 even though the test passed because method-b threw the EXPECTED_EXCEPTION INSPECTION_TODO: where would the expected_exception be thrown if DSI was not running?"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "Exec65Test.java:52",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process is killed by the watchdog. Note that this test is the validating-test from 00152, etc. but in this test, the DSI experiment resulted in a likely spurious verdict (the test passed) because method-b was before the critical point (DefaultExecutor.watchdog needs to be initialized/method-a needs to be called by DefaultExecutor.java:382), so the delayed call to method-a made the STATE_RESTORED."
            }

        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.issues.Exec65Test#testExec65WitSleepUsingSleepCommandDirectly",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.watchdog, which kills the subprocess if it is running for too long. method-b actually creates and launches the subprocess, but the linking between the field variable DefaultExecutor.watchdog and the subprocess is done by the caller of method-b, not method-b itself. Hence, these two methods don't have a temporal relationship.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-17-17",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 32,
        "inspection-start-time": "2022-02-05-20-57",
        "project": "commons-exec",
        "spec-id": "00172",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessErrorStream(Ljava/io/InputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "LV-verdict-count": 1,
        "LS-verdict-count": 38,
        "code-snippets-file": "snippets/lv-ls/00172.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:363",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test failed because there was no handler for the error stream of the subprocess because method-a was not called, and subsequently the output from the error stream that was expected to be in the variable baos (in the test) was not there, so the assertion failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:363",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This test is weak because it doesn't check for the error stream."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "method-a sets a value to the field variable PumpStreamHandler.errorThread (it is the only place in the code that does so, also not a pure setter), and method-b calls Thread.start() on the field variable PumpStreamHandler.errorThread in the case that it is initialized. So, if method-a was not called, the PumpStreamHandler would not be able to read standard error outputs from the subprocess. Most likely a bigger spec with ExecuteStreamHandler.setProcessInputStream() and ExecuteStreamHandler.setProcessOutputStream() with the same method-b. GOOD_EXAMPLE (only one LV test among many LS that are due to weak oracles) CHECKS_MISDIRECTED_OUTPUT",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-21-15",
        "inspection-time-in-minutes": 18
    },
    {
        "iid": 33,
        "inspection-start-time": "2022-02-05-21-15",
        "project": "commons-exec",
        "spec-id": "00173",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessErrorStream(Ljava/io/InputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "LV-verdict-count": 1,
        "LS-verdict-count": 38,
        "code-snippets-file": "snippets/lv-ls/00173.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:363",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test failed because there was no handler for the error stream of the subprocess because method-a was not called, and subsequently the output from the error stream that was expected to be in the variable baos (in the test) was not there, so the assertion failed."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:363",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This test is weak because it doesn't check for the error stream."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams shows the connection between method-a and method-b",
        "notes": "method-a sets a value to the field variable PumpStreamHandler.errorThread (it is the only place in the code that does so, also not a pure setter), and method-b stops the thread field variable PumpStreamHandler.errorThread in the case that it is initialized. The more stringent relationship is between ExecuteStreamHandler.start and method-b, rather than method-a and method-b. Most likely a bigger spec with method-a, ExecuteStreamHandler.setProcessInputStream() and ExecuteStreamHandler.setProcessOutputStream(), ExecuteStreamHandler.start(), and method-b. GOOD_EXAMPLE + CHECKS_MISDIRECTED_OUTPUT. DECISION: There is a larger spec that may look something like the regular expression (method-a? ExecuteStreamHandler.start method-b), but there is no direct relationship between method-a and method-b themselves. method-a itself can be safely called after method-b.",
        "findings": "There is a larger spec that may look something like the regular expression (method-a? ExecuteStreamHandler.start method-b)",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-05-21-23",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 34,
        "inspection-start-time": "2022-02-05-21-24",
        "project": "commons-exec",
        "spec-id": "00178",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessInputStream(Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 38,
        "LV-verdict-count": 1,
        "LS-verdict-count": 37,
        "code-snippets-file": "snippets/lv-ls/00178.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testStdInHandling",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:361",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test failed because the subprocess did not return a result after the 2000ms waittime was over. It seems like since by delaying method-a until after method-b the script couldn't read from its input stream (the outputstream that communicated with the subprocess's inputstream was set up by method-a, so there was no way for the test to send anything to the script), and the subprocess/script hung because it couldn't read an input."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:361",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": ""
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "method-a sets a value to the field variable PumpStreamHandler.inputThread (it is the only place in the code that does so, also not a pure setter), and method-b calls Thread.start() on the field variable PumpStreamHandler.inputThread in the case that it is initialized. So, if method-a was not called, the subprocess would not be able to read inputs from the PumpStreamHandler. Most likely a bigger spec with ExecuteStreamHandler.setProcessErrorStream() and ExecuteStreamHandler.setProcessOutputStream() with the same method-b. CHECKS_MISDIRECTED_OUTPUT",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-21-49",
        "inspection-time-in-minutes": 25
    },
    {
        "iid": 35,
        "inspection-start-time": "2022-02-05-22-48",
        "project": "commons-exec",
        "spec-id": "00185",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessOutputStream(Ljava/io/InputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "LV-verdict-count": 15,
        "LS-verdict-count": 24,
        "code-snippets-file": "snippets/lv-ls/00185.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:362",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The assertion failed because the test was expecting some value from the output stream that was supposed to be set via method-a, but the test got no output because of the delay of method-a."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithError",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:362",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is weak because it only checks the exit value from the process, not the output. Also, the test is technically EXPECTED_EXCEPTION, but that exception is not related to this DSI experiment."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "method-a sets a value to the field variable PumpStreamHandler.outputThread (it is the only place in the code that does so, also not a pure setter), and method-b calls Thread.start() on the field variable PumpStreamHandler.outputThread in the case that it is initialized. So, if method-a was not called, the PumpStreamHandler would not be able to read standard output outputs from the subprocess. Most likely a bigger spec with ExecuteStreamHandler.setProcessErrorStream() and ExecuteStreamHandler.setProcessInputStream() with the same method-b. CHECKS_MISDIRECTED_OUTPUT",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-22-57",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 36,
        "inspection-start-time": "2022-02-05-22-58",
        "project": "commons-exec",
        "spec-id": "00186",
        "method-a": "org.apache.commons.exec.ExecuteStreamHandler.setProcessOutputStream(Ljava/io/InputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 10,
        "test-methods-mine-count": 39,
        "LV-verdict-count": 15,
        "LS-verdict-count": 24,
        "code-snippets-file": "snippets/lv-ls/00186.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:362",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "The assertion failed because the test was expecting some value from the output stream that was supposed to be set via method-a, but the test got no output because of the delay of method-a.",
                "notes": ""
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithError",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:362",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "Note that this test is weak because it only checks the exit value from the process, not the output. Also, the test is technically EXPECTED_EXCEPTION, but that exception is not related to this DSI experiment."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "method-a sets a value to the field variable PumpStreamHandler.outputThread (it is the only place in the code that does so, also not a pure setter), and method-b stops the thread field variable PumpStreamHandler.outputThread in the case that it is initialized. The more stringent relationship is between method-a and ExecuteStreamHandler.start(), and between ExecuteStreamHandler.start() and method-b, rather than method-a and method-b. Most likely a bigger spec with method-a, ExecuteStreamHandler.setProcessInputStream() and ExecuteStreamHandler.setProcessErrorStream(), ExecuteStreamHandler.start(), and method-b. CHECKS_MISDIRECTED_OUTPUT DECISION: not calling `a` will not prevent stop(), or `b`, from executing successfully, since there is a nullness check inside stop(). So calling `a` before is strictly not necessary.",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-05-22-03",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 37,
        "inspection-start-time": "2022-02-06-13-30",
        "project": "commons-exec",
        "spec-id": "00244",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.checkException()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 4,
        "test-methods-mine-count": 8,
        "LV-verdict-count": 5,
        "LS-verdict-count": 3,
        "code-snippets-file": "snippets/lv-ls/00244.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test failed because ExecuteWatchdog.killedProcess returned false. Since method-a was delayed after method-b, by which point the subprocess that the watchdog should have monitored finished, the watchdog was not able to kill that process. (If method-a was called, then the subprocess would have been killed after 2 seconds, but since method-a was not called before the process executed, the subprocess was exited normally after 9 seconds. DELAY_CAUSES_TIMEOUT"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "DefaultExecutor.java:420",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called at all."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "method-a resets any info from the previous runs and starts the watchdog (which watches the process and terminates it if it runs for too long). In doing so, method-a sets the field variable ExecuteWatchdog.caught to null. method-b checks whether the field variable ExecuteWatchdog.caught is null, and throws it if it is not. I don't think there's a direct relationship between method-a and method-b; more like there should be something between method-a and method-b that may set the field variable ExecuteWatchdog.caught to a non-null value. So individaully these methods may be a part of a larger spec, but this spec isn't.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-13-53",
        "inspection-time-in-minutes": 23
    },
    {
        "iid": 38,
        "inspection-start-time": "2022-02-06-14-27",
        "project": "commons-exec",
        "spec-id": "00250",
        "method-a": "org.apache.commons.exec.ExecuteWatchdog.start(Ljava/lang/Process;)V",
        "method-b": "org.apache.commons.exec.ExecuteWatchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 5,
        "LS-verdict-count": 3,
        "code-snippets-file": "snippets/lv-ls/00250.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "DefaultExecutor.java:402",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test failed because ExecuteWatchdog.killedProcess returned false. Since method-a was delayed after method-b, by which point the subprocess that the watchdog should have monitored finished, the watchdog was not able to kill that process. (If method-a was called, then the subprocess would have been killed after 2 seconds, but since method-a was not called before the process executed, the subprocess was exited normally after 9 seconds. DELAY_CAUSES_TIMEOUT"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutor.java:383",
                        "method-b-site": "DefaultExecutor.java:402",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "both",
        "validating-test-file": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
        "notes": "This is a start-stop scenario. Nothing is directly stopping method-a from being called after method-b and vice versa, but calling method-a after method-b would cause the watchdog to montior a process that has technically already ended? It may be possible to violate this spec becuase of the lack of guards that prevent the two methods from being called in any order. MORE_COMPLEX_THAN_AB maybe (ab)* ",
        "findings": "Type-a/c: method-a is always followed by method-b, and method-b is always preceded by method-a",
        "part-of-bigger-spec": "yes",
        "inspection-end-time": "2022-02-06-14-37",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 39,
        "inspection-start-time": "2022-02-06-21-23",
        "project": "commons-exec",
        "spec-id": "00291",
        "method-a": "org.apache.commons.exec.Executor.setExitValue(I)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 1,
        "test-methods-mine-count": 3,
        "LV-verdict-count": 3,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00291.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "exception",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:440",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test crashes because method-a was supposed to set what it expects as a valid process exit value, but since method-a was delayed and not called by the time that method-b was called, the test threw the exception."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue2",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:440",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION - it seems that this test expects the exception that method-b guards, and calling method-a here is a kind of a no-op as the call to method-a sets 0 as a valid exit code, even though 0 is the canonical valid exit code. The exit code of the process is 1."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1 shows the connection between method-a and method-b",
        "notes": "The only implementation of method-a modifies the field variable DefaultExecutor.exitValues (the list of exit values signalling a valid run) to include the argument int value. method-b uses the field variable DefaultExecutor.exitValues to determine whether the exit value of the process implies that the process failed. The caller of method-b throws an exception if method-b returns true. DECISION: This seems like a CONNECTION_DOES_NOT_NECESSITATE_ORDERING case, given that the user may not want/need to set exit values other than zero to be valid in the general case (method-a is simply an extra option for the user). Moreover, setting an exit value other than the default to be valid may actually lead to faults, given that using only the default as the only valid exit value is a well-established convention.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-06-21-33",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 40,
        "inspection-start-time": "2022-02-07-00-11",
        "project": "commons-exec",
        "spec-id": "00309",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.closeProcessStreams(Ljava/lang/Process;)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 23,
        "LV-verdict-count": 12,
        "LS-verdict-count": 9,
        "code-snippets-file": "snippets/lv-ls/00309.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before DefaultExecutor.executeInternal() (the caller of method-b). CHECKS_MISDIRECTED_OUTPUT"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithError",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:412",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION, but doesn't seem related to the perturbation that DSI is making. Also, this is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler. The caller of method-b (DefaultExecutor.executeInternal()) receives as a final argument streams DefaultExecutor.streamHandler, and uses streams to connect the intended input/output/error streams between the parent and child processes. method-b closes the input/output/error streams of the subprocess. method-a ought to be called before DefaultExecutor.executeInternal() if the user wanted the input/output/error stream connection to the subprocess other than StdIn/StdOut/StdErr, but I don't think this extends to say that method-a needs to be called before method-b. CONNECTION_DOES_NOT_NECESSITATE_ORDERING  DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-00-39",
        "inspection-time-in-minutes": 28
    },
    {
        "iid": 41,
        "inspection-start-time": "2022-02-07-00-47",
        "project": "commons-exec",
        "spec-id": "00311",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.executeInternal(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;Lorg/apache/commons/exec/ExecuteStreamHandler;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 23,
        "LV-verdict-count": 14,
        "LS-verdict-count": 7,
        "code-snippets-file": "snippets/lv-ls/00311.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:175",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before method-b. CHECKS_MISDIRECTED_OUTPUT"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsync",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:47",
                        "invocation-count": 0
                    }
                ],
                "perturbation-count": 0,
                "comment-on-return-values": "NA",
                "notes": "The property was not satisfied, most likely because of concurrency. The Specialized Trace shows\na @ Thd[1]Obj[0]:0(DefaultExecutorTest.java:81)\nb @ Thd[27]Obj[0]:0(DefaultExecutor.java:47)\n. It seems like the sanity check failed because the threads in which the two methods occurred are different. INSPECTION_TODO to think about whether we want to permit cases like this? Also, note that the specified call site of method-b is incorrect; the site specified points to the declaration of the DefaultExecutor class."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "CONCURRENCY + GOOD_EXAMPLE + ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler. method-b receives as a final argument streams DefaultExecutor.streamHandler, and uses streams to connect the intended input/output/error streams between the parent and child processes. Hence, one *needs* to call method-a before method-b if one wants to set a different ExecuteStreamHandler object rather than the default (new PumpStreamHandler(), which redirects the subprocess output to StdOut), so this is a sometimes true spec.  DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-00-59",
        "inspection-time-in-minutes": 12
    },
    {
        "iid": 42,
        "inspection-start-time": "2022-02-07-00-59",
        "project": "commons-exec",
        "spec-id": "00312",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 14,
        "LV-verdict-count": 12,
        "LS-verdict-count": 4,
        "code-snippets-file": "snippets/lv-ls/00312.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before DefaultExecutor.executeInternal(), which is called from method-b."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler. method-b passes DefaultExecutor.streamHandler into DefaultExecutor.executeInternal() as a final argument, and uses streams to connect the intended input/output/error streams between the parent and child processes. Hence, one *needs* to call method-a before method-b if it wanted to set a different ExecuteStreamHandler object rather than the preset one (new PumpStreamHandler(), which redirects the subprocess output to StdOut), so this is a sometimes true spec.  DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-01-09",
        "inspection-time-in-minutes": 10
    },
    {
        "iid": 43,
        "inspection-start-time": "2022-02-07-01-46",
        "project": "commons-exec",
        "spec-id": "00314",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.getExceptionCaught()Ljava/io/IOException;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.io.IOException",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 23,
        "LV-verdict-count": 12,
        "LS-verdict-count": 9,
        "code-snippets-file": "snippets/lv-ls/00314.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before DefaultExecutor.executeInternal(), the caller of method-b. (The spec is less about the relationship between method-a and method-b, but more about the relationship between nethod-a and DefaultExecutor.executeInternal()). METHOD_B_AFTER_CRITICAL_POINT"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:414",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.streamHandler. ONE_STATELESS_METHOD: method-b is a 1-line naive getter to the field variable DefaultExecutor.exceptionCaught. Since these two field variables are not directly related, this is a spurious spec. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-01-55",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 44,
        "inspection-start-time": "2022-02-07-02-04",
        "project": "commons-exec",
        "spec-id": "00316",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.isFailure(I)Z",
        "method-a-return-type": "void",
        "method-b-return-type": "boolean",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 23,
        "LV-verdict-count": 12,
        "LS-verdict-count": 9,
        "code-snippets-file": "snippets/lv-ls/00316.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before DefaultExecutor.executeInternal(), the caller of method-b. (The spec is less about the relationship between method-a and method-b, but more about the relationship between nethod-a and DefaultExecutor.executeInternal()). METHOD_B_AFTER_CRITICAL_POINT"
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:431",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.streamHandler. method-b checks whether the given exit value indicates that the corresponding process has failed by using DefaultExecutor.exitValues. Since these two field variables are not directly related, this is a spurious spec. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-02-09",
        "inspection-time-in-minutes": 5
    },
    {
        "iid": 45,
        "inspection-start-time": "2022-02-07-11-59",
        "project": "commons-exec",
        "spec-id": "00317",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.launch(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;Ljava/io/File;)Ljava/lang/Process;",
        "method-a-return-type": "void",
        "method-b-return-type": "java.lang.Process",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 23,
        "LV-verdict-count": 12,
        "LS-verdict-count": 9,
        "code-snippets-file": "snippets/lv-ls/00317.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before DefaultExecutor.executeInternal(), the caller of method-b. (The spec is less about the relationship between method-a and method-b, but more about the relationship between nethod-a and DefaultExecutor.executeInternal())."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutor.java:351",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "snippet",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.streamHandler. method-b creates and starts a subprocess by using DefaultExecutor.launcher. Since these two field variables are not directly related, this is a spurious spec. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-12-05",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 46,
        "inspection-start-time": "2022-02-07-15-42",
        "project": "commons-exec",
        "spec-id": "00319",
        "method-a": "org.apache.commons.exec.Executor.setStreamHandler(Lorg/apache/commons/exec/ExecuteStreamHandler;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 2,
        "test-methods-mine-count": 14,
        "LV-verdict-count": 12,
        "LS-verdict-count": 4,
        "code-snippets-file": "snippets/lv-ls/00319.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:104",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expected some output via the OutputStream object baos, but the output from the subprocess didn't get propagated because method-a wasn't called before DefaultExecutor.executeInternal(), which is called from method-b."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithCustomExitValue1",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:81",
                        "method-b-site": "DefaultExecutorTest.java:442",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This is a weak oracle for this spec, given that the test doesn't check for the outputstream after the process execution."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "ONE_PURE_SETTER: method-a is a pure setter for the field variable DefaultExecutor.streamHandler. The callee of method-b passes DefaultExecutor.streamHandler into DefaultExecutor.executeInternal() as a final argument streams, and uses streams to connect the intended input/output/error streams between the parent and child processes. Hence, one *needs* to call method-a before method-b if it wanted to set a different ExecuteStreamHandler object rather than the preset one (new PumpStreamHandler(), which redirects the subprocess output to StdOut), so this is a sometimes true spec.  DECISION `a` is public and can be called at anytime. If `a` is not called, a default streamhandler is used that is based on System.err and System.out; so calling `a` before `b` is not necessary. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-15-50",
        "inspection-time-in-minutes": 8
    },
    {
        "iid": 47,
        "inspection-start-time": "2022-02-07-15-50",
        "project": "commons-exec",
        "spec-id": "00343",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.DefaultExecutor.execute(Lorg/apache/commons/exec/CommandLine;Ljava/util/Map;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "LV-verdict-count": 1,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00343.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithInvalidWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:125",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION_NOT_THROWN - method-b was supposed to throw a IOException because DefaultExecutor.workingDirectory was supposed to be set to a non-existing directory, but since method-a was not called by that point, the expected exception was not thrown."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutor.java:161",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithInvalidWorkingDirectory",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. method-b checks whether DefaultExecutor.workingDirectory is set to an existing directory, and throws an exception if it is not set, or passes the directory to DefaultExecutor.executeInternal() if it is valid. While the constructor of DefaultExecutor sets DefaultExecutor.workingDirectory to the current directory, this would be a sometimes true spec based on whether the user wants the subprocess to run in a different directory. DECISION `a` is public and can be called at anytime. Not calling `a` does not necessarily mean that the program is wrong, as the working directory can be set without calling `a` via the constructor",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-15-59",
        "inspection-time-in-minutes": 9
    },
    {
        "iid": 48,
        "inspection-start-time": "2022-02-07-16-13",
        "project": "commons-exec",
        "spec-id": "00347",
        "method-a": "org.apache.commons.exec.Executor.setWorkingDirectory(Ljava/io/File;)V",
        "method-b": "org.apache.commons.exec.Executor.execute(Lorg/apache/commons/exec/CommandLine;)I",
        "method-a-return-type": "void",
        "method-b-return-type": "int",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "LV-verdict-count": 1,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00347.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithInvalidWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:125",
                        "method-b-site": "DefaultExecutorTest.java:127",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "EXPECTED_EXCEPTION_NOT_THROWN - method-b was supposed to throw a IOException because DefaultExecutor.workingDirectory was supposed to be set to a non-existing directory, but since method-a was not called by that point, the expected exception was not thrown."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithWorkingDirectory",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "DefaultExecutorTest.java:114",
                        "method-b-site": "DefaultExecutorTest.java:115",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test is somewhat weak because the script that it runs doesn't use its working directory at all (it consists of a single echo command). I feel like a better script for testing this would be one that writes to a file in the working directory, or it prints the path to the working directory?"
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithInvalidWorkingDirectory",
        "notes": "ONE_PURE_SETTER: The only implementation of method-a is a pure setter to the field variable DefaultExecutor.workingDirectory. The callee of method-b checks whether DefaultExecutor.workingDirectory is set to an existing directory, and throws an exception if it is not set, or passes the directory to DefaultExecutor.executeInternal() if it is valid. While the constructor of DefaultExecutor sets DefaultExecutor.workingDirectory to the current directory, this would be a sometimes true spec based on whether the user wants the subprocess to run in a different directory. DECISION `a` is public and can be called at anytime. Not calling `a` does not necessarily mean that the program is wrong, as the working directory can be set without calling `a` via the constructor",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-16-16",
        "inspection-time-in-minutes": 3
    },
    {
        "iid": 49,
        "inspection-start-time": "2022-02-07-18-23",
        "project": "commons-exec",
        "spec-id": "00355",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createProcessErrorPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "LV-verdict-count": 1,
        "LS-verdict-count": 35,
        "code-snippets-file": "snippets/lv-ls/00355.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:129",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expects the error stream output from the process to be outputted from the ByteArrayOutputStream baos, but since method-a was not called before method-b, the error stream output from the proess was not outputted to baos."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:129",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test passes because there is no error output from the script that is being run, and so the test doesn't check the error stream."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "method-a sets the field variable PumpStreamHandler.errorThread to the approporiate pump that copies the error output from the subprocess to the appropriate stream (it is not a pure setter). The only implementation of method-b starts the thread in PumpStreamHandler.errorThread only if the field variable was initialized by that point. So, if method-a was not called before method-b, the error output from the subprocess will not be redirected to the parent process. (This is a SOMETIMES_TRUE_SPEC - there is a chance that the user doesn't want to redirect error output, although I don't really see a reason for that.) CHECKS_MISDIRECTED_OUTPUT",
        "findings": "We can most likely encode this as a (ab|b) spec - MORE_COMPLEX_THAN_AB.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-18-54",
        "inspection-time-in-minutes": 32
    },
    {
        "iid": 50,
        "inspection-start-time": "2022-02-07-18-54",
        "project": "commons-exec",
        "spec-id": "00356",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createProcessErrorPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "LV-verdict-count": 1,
        "LS-verdict-count": 35,
        "code-snippets-file": "snippets/lv-ls/00356.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:129",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expects the error stream output from the process to be outputted from the ByteArrayOutputStream baos, but since method-a was not called before ExecuteStreamHandler.start(), the error stream output from the proess was not outputted to baos."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:129",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test passes because there is no error output from the script that is being run, and so the test doesn't check the error stream."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
        "notes": "method-a sets the field variable PumpStreamHandler.errorThread to the approporiate pump that copies the error output from the subprocess to the appropriate stream (it is not a pure setter). method-b stops the PumpStreamHandler.errorThread from running (if it is set at that point). While method-b would not operate on PumpStreamHandler.errorThread if method-a is not called in the first place, I think the actual relationship is between method-a and PumpStreamHandler.start(), and between PumpStreamHandler.start() and method-b instead of a direct relationship between method-a and method-b (since method-a initializes PumpStreamHandler.errorThread but doesn't start running it, while method-b stops an active run of PumpStreamHandler.errorThread).  DECISION: not calling `a` will not prevent stop(), or `b`, from executing successfully, since there is a nullness check inside stop(). So calling `a` before is strictly not necessary. CHECKS_MISDIRECTED_OUTPUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-19-08",
        "inspection-time-in-minutes": 14
    },
    {
        "iid": 51,
        "inspection-start-time": "2022-02-07-19-14",
        "project": "commons-exec",
        "spec-id": "00359",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createProcessOutputPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "LV-verdict-count": 15,
        "LS-verdict-count": 21,
        "code-snippets-file": "snippets/lv-ls/00359.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:116",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expects the standard output stream from the process to be outputted from the ByteArrayOutputStream baos, but since method-a was not called before method-b, the standard output from the proess was not outputted to baos."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:116",
                        "method-b-site": "DefaultExecutor.java:372",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This test passes because it only checks that the error output got propagated to baos, not the standard output output. So, we can say that this is a weak test for this spec."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "method-a sets the field variable PumpStreamHandler.outputThread to the approporiate pump that copies the error output from the subprocess to the appropriate stream (it is not a pure setter). The only implementation of method-b only starts the thread in PumpStreamHandler.outputThread only if it was initialized by that point. So, if method-a was not called before method-b, the standard output from the subprocess will not be redirected to the parent process. (This is a SOMETIMES_TRUE_SPEC - there is a chance that the user doesn't want to redirect standard output, although I don't really see a reason for that.) CHECKS_MISDIRECTED_OUTPUT",
        "findings": "We can most likely encode this as a (ab|b) spec - MORE_COMPLEX_THAN_AB.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-19-20",
        "inspection-time-in-minutes": 6
    },
    {
        "iid": 52,
        "inspection-start-time": "2022-02-07-19-20",
        "project": "commons-exec",
        "spec-id": "00360",
        "method-a": "org.apache.commons.exec.PumpStreamHandler.createProcessOutputPump(Ljava/io/InputStream;Ljava/io/OutputStream;)V",
        "method-b": "org.apache.commons.exec.ExecuteStreamHandler.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "inheritance",
        "all-tests-mined": false,
        "test-classes-mine-count": 9,
        "test-methods-mine-count": 37,
        "LV-verdict-count": 15,
        "LS-verdict-count": 21,
        "code-snippets-file": "snippets/lv-ls/00360.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:116",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because it expects the standard output stream from the process to be outputted from the ByteArrayOutputStream baos, but since method-a was not called before method-b, the system output from the proess was not outputted to baos."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithRedirectedStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "PumpStreamHandler.java:116",
                        "method-b-site": "DefaultExecutor.java:406",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "This test passes because it only checks that the error output got propagated to baos, not the system output. So, we can say that this is a weak test for this spec."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecute",
        "notes": "method-a sets the field variable PumpStreamHandler.outputThread to the approporiate pump that copies the system output from the subprocess to the appropriate stream (it is not a pure setter). method-b stops the PumpStreamHandler.outputThread from running (if it is set at that point). While method-b would not operate on PumpStreamHandler.outputThread if method-a is not called in the first place, I think the actual relationship is between method-a and PumpStreamHandler.start(), and between PumpStreamHandler.start() and method-b instead of a direct relationship between method-a and method-b (since method-a initializes PumpStreamHandler.outputThread but doesn't start running it, while method-b stops an active run of PumpStreamHandler.outputThread.)  DECISION: not calling `a` will not prevent stop(), or `b`, from executing successfully, since there is a nullness check inside stop(). So calling `a` before is strictly not necessary.",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-07-19-24",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 53,
        "inspection-start-time": "2022-02-07-22-04",
        "project": "commons-exec",
        "spec-id": "00375",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer$ProcessDestroyerImpl.setShouldDestroy(Z)V",
        "method-b": "org.apache.commons.exec.ShutdownHookProcessDestroyer$ProcessDestroyerImpl.join(J)V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "LV-verdict-count": 1,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00375.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-1-f2-precond",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "ShutdownHookProcessDestroyer.java:155",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:159",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because method-a is not called before the ProcessDestroyerImpl thread is run. This causes the ShutdownHookProcessDestroyer object to destroy the subprocess completely."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ShutdownHookProcessDestroyer.java:155",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:159",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test passes here but the DSI experiment takes a MUCH longer time (21.8 seconds, in comparison to the 2.56 seconds from the sanity checks) to complete because not calling method-a before method-b forces the test to wait via method-b, while if method-a was called before method-b the thread that method-b is waiting on would end instantaneously. GOOD_EXAMPLE?"
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ProcessDestroyerImpl.shouldDestroy to false. This causes the thread running ProcessDestroyerImpl (when it is run and being waited on via method-b) to *not* run ShutdownHookProcessDestroyer.run() (would kill the running process before it is completely done). So, method-a *needs* to be called in the case that the process terminated/was killed by the watchdog instead of the VM terminating. SOMETIMES_TRUE_SPEC? DELAY_CAUSES_TIMEOUT",
        "findings": "This is a UNINTERESTING_SPEC, as method-a and method-b are both public methods within a private class, and their only use case is within ShutdownHookProcessDestroyer.removeShutdownHook(). So, there is no way a user can break this spec.",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-22-37",
        "inspection-time-in-minutes": 33
    },
    {
        "iid": 54,
        "inspection-start-time": "2022-02-07-22-37",
        "project": "commons-exec",
        "spec-id": "00376",
        "method-a": "org.apache.commons.exec.ShutdownHookProcessDestroyer$ProcessDestroyerImpl.setShouldDestroy(Z)V",
        "method-b": "org.apache.commons.exec.ShutdownHookProcessDestroyer$ProcessDestroyerImpl.start()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 0,
        "test-methods-mine-count": 2,
        "LV-verdict-count": 1,
        "LS-verdict-count": 1,
        "code-snippets-file": "snippets/lv-ls/00376.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
                "stage": "stage-1-f2-precond",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "ShutdownHookProcessDestroyer.java:155",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:156",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The test fails because method-a is not called before the ProcessDestroyerImpl thread is run. This causes the ShutdownHookProcessDestroyer object to destroy the subprocess completely, causing the call to handler.onProcessComplete()/handler.onProcessFailed() to not happen. This surfaces in the test because it checks whether the handler has a result from the subprocess."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWithProcessDestroyer",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ShutdownHookProcessDestroyer.java:155",
                        "method-b-site": "ShutdownHookProcessDestroyer.java:156",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "INSPECTION_TODO: fill in these notes!"
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": false,
        "spec-type": "precondition",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteAsyncWithProcessDestroyer",
        "notes": "ONE_PURE_SETTER: method-a sets the field variable ProcessDestroyerImpl.shouldDestroy to false. This causes the thread running ProcessDestroyerImpl (when it is run via method-b) to *not* run ShutdownHookProcessDestroyer.run() (would kill the running process before it is completely done). So, method-a *needs* to be called in the case that the subprocess terminated/was killed by the watchdog instead of the VM terminating, so that if there are further items that need to be run via the parent process.",
        "findings": "This is a UNINTERESTING_SPEC, as method-a and method-b are both public methods within a private class, and their only use case is within ShutdownHookProcessDestroyer.removeShutdownHook(). So, there is no way a user can break this spec.",
        "findings": "Type-c: method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-07-22-41",
        "inspection-time-in-minutes": 4
    },
    {
        "iid": 55,
        "inspection-start-time": "2022-02-08-00-14",
        "project": "commons-exec",
        "spec-id": "00388",
        "method-a": "org.apache.commons.exec.Watchdog.addTimeoutObserver(Lorg/apache/commons/exec/TimeoutObserver;)V",
        "method-b": "org.apache.commons.exec.Watchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 4,
        "LS-verdict-count": 4,
        "code-snippets-file": "snippets/lv-ls/00388.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:90",
                        "method-b-site": "ExecuteWatchdog.java:142",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The assertion failed because the watchdog didn't kill the subprocess, as the test was expecting it to. This is because method-a was never called, which means that Watchdog.fireTimeoutOccurred() didn't get to call ExecuteWatchdog.timeoutOccurred(), so the process kept going on after the timeout and exited normally."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:90",
                        "method-b-site": "ExecuteWatchdog.java:142",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "spurious-spec",
        "is-oracle-weak": true,
        "spec-type": "NA",
        "validating-test-file": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
        "notes": "method-a adds an element to the field variable Watchdog.observers. method-b creates and starts a new thread to run the Watchdog object it is called on (so, the thread runs Watchdog.run()). I think the critical point at which method-a needs to be called is by Watchdog.fireTimeoutOccurred(), because that's where the field variable Watchdog.observers is used. Because the call to method-b can be made before that point (eg. in the case that the process exited normally), I think this is technically a spurious spec. DELAY_CAUSES_TIMEOUT",
        "part-of-bigger-spec": "no",
        "inspection-end-time": "2022-02-08-00-25",
        "inspection-time-in-minutes": 11
    },
    {
        "iid": 56,
        "inspection-start-time": "2022-02-08-00-37",
        "project": "commons-exec",
        "spec-id": "00391",
        "method-a": "org.apache.commons.exec.Watchdog.start()V",
        "method-b": "org.apache.commons.exec.Watchdog.stop()V",
        "method-a-return-type": "void",
        "method-b-return-type": "void",
        "same-class": "yes",
        "all-tests-mined": false,
        "test-classes-mine-count": 3,
        "test-methods-mine-count": 6,
        "LV-verdict-count": 5,
        "LS-verdict-count": 3,
        "code-snippets-file": "snippets/lv-ls/00391.java",
        "validated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
                "stage": "stage-3-complete",
                "exception-or-assertion": "assertion",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:120",
                        "method-b-site": "ExecuteWatchdog.java:142",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "The assertion failed because the watchdog didn't kill the subprocess, as the test was expecting it to. This is because method-a was never called, which means that the thread that was supposed to call Watchdog.fireTimeoutOccurred() and kill the process on timeout was never started, so the process kept going on after the timeout and exited normally."
            }
        ],
        "invalidated-inspected-cases": [
            {
                "test": "org.apache.commons.exec.DefaultExecutorTest#testExecuteWatchdogVeryLongTimeout",
                "stage": "stage-3-complete",
                "exception-or-assertion": "NA",
                "invocation-info": [
                    {
                        "method-a-site": "ExecuteWatchdog.java:120",
                        "method-b-site": "ExecuteWatchdog.java:142",
                        "invocation-count": 1
                    }
                ],
                "perturbation-count": 1,
                "comment-on-return-values": "method-a returns void.",
                "notes": "IMPLICITLY_EXPECTED_EXCEPTION, but the exception is supposed to be thrown indirectly from method-b after the process exits. The purpose of this test is to check whether when a watchdog is given a long time, the process exits normally instead of the watchdog coming in to kill it. Its oracles are weak for checking the relationship between method-a and method-b because it doesn't really check that method-a was called."
            }
        ],
        "verdict": "true-spec",
        "is-oracle-weak": true,
        "spec-type": "both",
        "validating-test-file": "org.apache.commons.exec.issues.Exec41Test#testExec41WithStreams",
        "notes": "This is a classic start-stop scenario; method-a sets Watchdog.stopped to false and starts the thread that runs the Watchdog in order to kill the subprocess when the timeout occurs. method-b stops this thread and sets Watchdog.stopped to true. Hence, this is a true spec.",
        "findings": "Type-a/c: method-a is always followed by method-b, and method-b is always preceded by method-a",
        "part-of-bigger-spec": "tbd",
        "inspection-end-time": "2022-02-08-00-45",
        "inspection-time-in-minutes": 8
    }

]
